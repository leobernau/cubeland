<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bernau Games - CubeLand v2.4</title>
<style>
:root{
  --bg-top:#04050a;
  --bg-bottom:#081225;
  --tile:#0c1b2b;
  --tileEdge:#12324b;
  --neon1:#06b6d4;
  --neon2:#7c3aed;
  --neon3:#f472b6;
  --neon4:#22c55e;
  --gold:#f6c84c;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff}
#wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px}
canvas#game{width:100%;height:100%;max-width:1400px;max-height:860px;border-radius:12px;background:#071226;border:1px solid rgba(255,255,255,.04);box-shadow:0 40px 140px rgba(0,0,0,.75);display:block}
.hud{position:absolute;left:18px;top:14px;display:flex;gap:8px;z-index:60}
.pill{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);border-radius:999px;padding:8px 12px;font-weight:800}
.right{position:absolute;right:18px;top:14px;display:flex;gap:8px;z-index:60}
.icon{width:42px;height:36px;display:grid;place-items:center;border-radius:10px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.06);cursor:pointer;user-select:none}
.icon:active{transform:scale(.98)}
.overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(5,8,15,.78);z-index:80}
.overlay.show{display:grid}
.card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:16px;max-width:980px;width:min(94vw,980px);box-shadow:0 30px 90px rgba(0,0,0,.6)}
.row{display:flex;gap:10px;align-items:center;justify-content:space-between}
.cta{background:linear-gradient(90deg,var(--neon2),var(--neon1));border:none;border-radius:10px;padding:10px 14px;color:#fff;font-weight:900;cursor:pointer}
.ghost{background:transparent;border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px 12px;color:#fff;cursor:pointer}
.small{font-size:12px;opacity:.85}
.close{position:absolute;right:10px;top:10px;border-radius:999px;background:rgba(255,255,255,.06);padding:6px 8px;cursor:pointer}
.shop-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;max-height:52vh;overflow:auto;margin-top:8px}
.skin-card{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
.preview{height:96px;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#07121f,#050b15)}
@media (max-width:640px){canvas#game{border-radius:8px}}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="720" aria-label="Bernau Games CubeLand"></canvas>

  <div class="hud">
    <div class="pill">üéÆ Bernau Games - CubeLand</div>
    <div class="pill">üìè Score: <b id="hudScore">0</b></div>
    <div class="pill">üèÜ Best: <b id="hudBest">0</b></div>
    <div class="pill">ü™ô Coins: <b id="hudCoins">0</b></div>
  </div>

  <div class="right">
    <div class="icon" id="btnPause" title="Pause (P)">‚è∏</div>
    <div class="icon" id="btnMute" title="Mute (M)">üîä</div>
    <div class="icon" id="btnShop" title="Shop (S)">üõçÔ∏è</div>
    <div class="icon" id="btnHelp" title="Hilfe (H)">‚ùì</div>
  </div>

  <!-- Intro -->
  <div id="olMenu" class="overlay show">
    <div class="card">
      <div class="row">
        <h2 style="margin:0">Bernau Games ‚Äî CubeLand (v2.4)</h2>
        <div class="small">Endlos ¬∑ Zuf√§llige Portale ¬∑ Neon Dark</div>
      </div>
      <p style="margin-top:8px">Springe √ºber Bl√∂cke & Stacheln, sammle M√ºnzen auf denselben Bl√∂cken wie Boden/Decke. Portale erzeugen Spezial-Sektionen (Ship/Flip), danach R√ºckkehr. Shop (S) f√ºr Skins.</p>
      <div class="row" style="margin-top:12px">
        <div>
          <button class="cta" id="btnPlay">‚ñ∂Ô∏è Spielen</button>
          <button class="ghost" id="btnOpenShop">üõçÔ∏è Shop</button>
        </div>
        <div class="small">Steuerung: Space/Tap = Springen (Ship: halten = steigen). P = Pause ¬∑ S = Shop ¬∑ M = Mute ¬∑ R = Neustart</div>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="olGO" class="overlay">
    <div class="card">
      <h2 style="margin:0">Game Over</h2>
      <p class="small">Score: <b id="goScore">0</b> ¬∑ Best: <b id="goBest">0</b></p>
      <div class="row" style="margin-top:10px">
        <button class="cta" id="btnRestart">‚Ü∫ Neustarten (R)</button>
        <button class="ghost" id="btnGoShop">üõçÔ∏è Shop</button>
      </div>
    </div>
  </div>

  <!-- Shop -->
  <div id="olShop" class="overlay">
    <div class="card" style="position:relative">
      <div class="close" id="shopClose">‚úï</div>
      <h3 style="margin:0 0 6px 0">Shop ‚Äî Skins</h3>
      <p class="small">Skins m√ºssen gekauft werden, bevor sie aktiviert werden k√∂nnen.</p>
      <div id="skinGrid" class="shop-grid"></div>
      <div class="row" style="margin-top:10px">
        <div>Deine Coins: <b id="shopCoins">0</b></div>
        <button class="ghost" id="btnCloseShop">Schlie√üen</button>
      </div>
    </div>
  </div>

  <!-- Help -->
  <div id="olHelp" class="overlay">
    <div class="card" style="position:relative;max-width:560px">
      <div class="close" id="helpClose">‚úï</div>
      <h3>Hilfe</h3>
      <p class="small">Normal: Springen (Space/Tap). Ship: Halten steigt, loslassen sinkt. Flip: invertierte Gravitation (oben ist Boden). Du landest auf Block-Tops (Top-Collision); Seitenkollision oder Stachel ‚áí Tod.</p>
      <div style="text-align:center;margin-top:8px"><button class="cta" id="helpOk">Verstanden</button></div>
    </div>
  </div>

</div>

<script>
/* ====================
   CubeLand v2.4 (Full)
   - Endless level with random portals and sections
   - Blocks & spikes combos, platform patterns
   - Coins on same tiles as floor/ceiling
   - Shop + skins, UI, audio, persistence
   - Higher jump + rotation
   ==================== */

/* --------------------
   Persistence
   -------------------- */
const LS_KEY = 'bernau_cubeland_v24';
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY)||'{}');
    return {
      coins: s.coins ?? 0,
      best: s.best ?? 0,
      owned: Array.isArray(s.owned) ? s.owned : ['skin_default'],
      active: s.active || 'skin_default',
      muted: !!s.muted
    };
  }catch(e){ return {coins:0,best:0,owned:['skin_default'],active:'skin_default',muted:false}; }
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){} }
let state = loadState();

/* --------------------
   Canvas
   -------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
function fitCanvas(){
  const p = canvas.parentElement.getBoundingClientRect();
  let w = Math.min(p.width, 1400);
  let h = Math.min(p.height, 860);
  const ratio = 16/9;
  if(w/h > ratio) w = Math.round(h*ratio); else h = Math.round(w/ratio);
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.round(w*DPR); canvas.height = Math.round(h*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();
const W = ()=>canvas.width / DPR;
const H = ()=>canvas.height / DPR;

/* --------------------
   Audio (simple)
   -------------------- */
let audioCtx = null, masterGain = null;
function initAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    masterGain = audioCtx.createGain(); masterGain.gain.value = state.muted ? 0 : 0.7; masterGain.connect(audioCtx.destination);
    buildAmbient();
  }catch(e){ console.warn('audio fail', e); }
}
function buildAmbient(){
  if(!audioCtx) return;
  const g = audioCtx.createGain(); g.gain.value = 0.06; g.connect(masterGain);
  const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = 110; o.connect(g); o.start();
  const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.08;
  const lfg = audioCtx.createGain(); lfg.gain.value = 0.03; lfo.connect(lfg); lfg.connect(g.gain); lfo.start();
}
function sfx(freq=900, dur=0.06, type='sine', vol=0.12){
  if(!audioCtx || state.muted) return;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(masterGain);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
function toggleMute(){ state.muted = !state.muted; if(masterGain) masterGain.gain.value = state.muted?0:0.7; document.getElementById('btnMute').textContent = state.muted ? 'üîà' : 'üîä'; saveState(); }

/* --------------------
   Game config
   -------------------- */
const G = {
  tile: 48,            // square tile size (also used for ceiling/floor)
  floorH: 64,          // floor height band
  gravity: 1.0,
  jump: -18.5,         // higher jump ‚Äî you asked for more jump
  shipThrust: -0.65,   // ship ascent per frame while holding
  speedBase: 5.0,
  speedMax: 11.0,
  spawnBase: 820,      // ms between normal patterns
  patternSpacing: 160, // px spacing multiplier
  coinR: 12,
  sectionLengthPx: 5200
};

/* --------------------
   Modes
   -------------------- */
const MODE = { NORMAL:'normal', SHIP:'ship', FLIP:'flip' };
let gameMode = MODE.NORMAL;

/* --------------------
   Player
   -------------------- */
let player = {
  x: 180,
  y: 0,
  w: 60,
  h: 60,
  vy: 0,
  onGround: true,
  alive: true,
  rot: 0,
  skin: state.active || 'skin_default'
};

/* --------------------
   Skins
   -------------------- */
const skins = [];
function addSkin(id,name,shape,body,accent,price){
  skins.push({id,name,shape,body,accent,price});
}
addSkin('skin_default','Neon Noir','cube','#000000','#06b6d4',0);
addSkin('skin_pulse','Pulse','cube','#081026','#7c3aed',30);
addSkin('skin_mint','Mint','rounded','#06121a','#22c55e',40);
addSkin('skin_fire','Fire','cube','#0b0b0b','#f472b6',70);
if(!state.owned.includes('skin_default')) state.owned.push('skin_default');
if(!skins.find(s=>s.id===state.active)) state.active = 'skin_default';

/* --------------------
   World state
   -------------------- */
let lastTs = 0;
let obstacles = []; // blocks, spikes, portals
let coins = [];
let particles = [];
let spawnTimer = 0;
let distance = 0;
let score = 0;
let speed = G.speedBase;
let inSection = false;
let sectionEndX = 0;

/* --------------------
   Object constructors
   -------------------- */
function makeBlock(x,y,w,h){ return { type:'block', x,y,w,h, passed:false }; }
function makeSpike(x,y,base){ return { type:'spike', x,y,w:base,h:base, passed:false }; }
function makeCoin(x,y){ return { x,y,r:G.coinR, taken:false }; }
function makePortal(x,y,kind){ return { type:'portal', x,y,w:56,h:56,kind,triggered:false,passed:false }; }

/* --------------------
   Utility
   -------------------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }
function AABB(ax,ay,aw,ah,bx,by,bw,bh){ return !(ax+aw<bx || bx+bw<ax || ay+ah<by || by+bh<ay); }
function lerp(a,b,t){ return a + (b-a)*t; }
function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* --------------------
   Drawing helpers
   -------------------- */
function drawBackground(){
  const g = ctx.createLinearGradient(0,0,0,H());
  g.addColorStop(0,'#04050a'); g.addColorStop(1,'#081225');
  ctx.fillStyle = g; ctx.fillRect(0,0,W(),H());
}

function drawParallax(){
  const t = Date.now()*0.001;
  for(let i=0;i<6;i++){
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = (i%3===0)?'var(--neon1)':(i%3===1)?'var(--neon2)':'var(--neon3)';
    const x = ((t*30)+i*220) % (W()+360) - 180;
    ctx.beginPath(); ctx.ellipse(x, 80 + (i%2)*34, 120, 34, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* draw tile strip for floor/ceiling */
function drawTileBand(y,rows=2){
  const t = G.tile;
  for(let r=0;r<rows;r++){
    const yy = y + r*t;
    for(let x=-t; x < W()+t; x += t){
      ctx.fillStyle = 'var(--tile)';
      ctx.fillRect(x, yy, t, t);
      ctx.strokeStyle = 'rgba(255,255,255,.04)';
      ctx.strokeRect(x+0.5, yy+0.5, t-1, t-1);
    }
  }
}

/* draw block */
function drawBlock(b){
  ctx.fillStyle = '#0f2d2b';
  ctx.fillRect(b.x, b.y, b.w, b.h);
  ctx.fillStyle = '#0c3f38';
  ctx.fillRect(b.x-6, b.y-12, b.w+12, 12);
  ctx.strokeStyle = 'rgba(6,182,212,0.16)';
  ctx.lineWidth = 2;
  ctx.strokeRect(b.x, b.y, b.w, b.h);
}

/* draw spike (triangle) with neon edge */
function drawSpike(s){
  ctx.fillStyle = '#05060a';
  ctx.beginPath();
  ctx.moveTo(s.x, s.y + s.h);
  ctx.lineTo(s.x + s.w/2, s.y);
  ctx.lineTo(s.x + s.w, s.y + s.h);
  ctx.closePath(); ctx.fill();
  const neon = (Math.floor(s.x/64)%3===0)?'var(--neon1)':(Math.floor(s.x/64)%3===1)?'var(--neon2)':'var(--neon3)';
  // compute actual color string
  const color = getComputedStyle(document.documentElement).getPropertyValue(neon).trim() || '#06b6d4';
  ctx.strokeStyle = color;
  ctx.lineWidth = 2; ctx.stroke();
}

function drawPortal(p){
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.fillStyle = p.kind==='ship' ? '#ffd54f' : (p.kind==='flip' ? '#7c3aed' : '#60a5fa');
  ctx.fillRect(0,0,p.w,p.h);
  ctx.strokeStyle = 'rgba(255,255,255,.22)'; ctx.lineWidth = 2; ctx.strokeRect(0,0,p.w,p.h);
  ctx.restore();
}

function drawCoin(c){
  ctx.save(); ctx.translate(c.x, c.y);
  ctx.fillStyle = 'var(--gold)'; ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,.6)'; ctx.beginPath(); ctx.arc(-c.r*0.25, -c.r*0.25, c.r*0.45, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* draw player (neon noir default or chosen skin) */
function drawPlayer(){
  const p = player;
  ctx.save();
  ctx.translate(p.x + p.w/2, p.y + p.h/2);
  ctx.rotate(p.rot);
  const skin = skins.find(s=>s.id===state.active) || skins[0];
  const body = skin.id==='skin_default' ? '#000' : skin.body;
  const accent = skin.id==='skin_default' ? '#06b6d4' : (skin.accent || '#06b6d4');
  roundRect(-p.w/2, -p.h/2, p.w, p.h, 8);
  ctx.fillStyle = body; ctx.fill();
  ctx.strokeStyle = accent; ctx.lineWidth = 3;
  // neon stripes
  ctx.beginPath(); ctx.moveTo(-p.w/2+8, -p.h/6); ctx.lineTo(p.w/2-8, -p.h/6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-p.w/2+8, p.h/6); ctx.lineTo(p.w/2-8, p.h/6); ctx.stroke();
  // glow outline
  ctx.shadowColor = accent; ctx.shadowBlur = 12;
  ctx.strokeRect(-p.w/2, -p.h/2, p.w, p.h);
  ctx.shadowBlur = 0;
  // eye
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.w*0.18, -p.h*0.14, p.w*0.10, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.w*0.20, -p.h*0.14, p.w*0.045, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* --------------------
   Patterns (combined obstacles)
   - All patterns use block tiles same as floor/ceiling (tile grid)
   - Coins are placed on top of blocks (same tile look)
   -------------------- */
function spawnPatternNormal(baseX){
  // several pattern types chosen randomly
  const t = G.tile;
  const groundY = H() - G.floorH;
  const r = Math.random();
  if(r < 0.18){
    // small step ladder + spike on top step
    const steps = 3;
    for(let i=0;i<steps;i++){
      const h = t*(1 + i);
      obstacles.push(makeBlock(baseX + i*(t*1.9), groundY - h, t*1.6, h));
      coins.push(makeCoin(baseX + i*(t*1.9) + t*0.8, groundY - h - 18));
      if(i===steps-1) obstacles.push(makeSpike(baseX + i*(t*1.9) + t*0.4, groundY - h - t*0.9, t*1.6));
    }
  } else if(r < 0.36){
    // triple low blocks (platform hop)
    for(let i=0;i<3;i++){
      obstacles.push(makeBlock(baseX + i*(t*2.6), groundY - t*1.4, t*1.8, t*1.4));
      coins.push(makeCoin(baseX + i*(t*2.6) + t*0.9, groundY - t*1.4 - 18));
    }
  } else if(r < 0.54){
    // gap + kicker block mid + spike ahead
    obstacles.push(makeSpike(baseX - t*0.6, groundY - t*0.1, t*1.4));
    obstacles.push(makeBlock(baseX + t*2.4, groundY - t*2, t*1.8, t*2));
    coins.push(makeCoin(baseX + t*2.4 + t*0.9, groundY - t*2 - 18));
  } else if(r < 0.72){
    // spike wave (several spikes in a row)
    for(let i=0;i<5;i++){
      obstacles.push(makeSpike(baseX + i*(t*1.2), groundY - t*0.1, t*1.5));
      if(i%2===0) coins.push(makeCoin(baseX + i*(t*1.2) + t*0.6, groundY - t*1.6));
    }
  } else {
    // tall block then small block for double jump
    obstacles.push(makeBlock(baseX, groundY - t*3, t*1.8, t*3));
    obstacles.push(makeBlock(baseX + t*3.2, groundY - t*1.4, t*1.8, t*1.4));
    coins.push(makeCoin(baseX + t*0.9, groundY - t*3 - 18));
    coins.push(makeCoin(baseX + t*3.2 + t*0.9, groundY - t*1.4 - 18));
  }
}

/* Ship section: narrow tunnel top/bottom (ship required) */
function spawnShipSection(startX){
  const t = G.tile, groundY = H() - G.floorH;
  let x = startX;
  const segs = 11;
  for(let i=0;i<segs;i++){
    const topH = t*(1 + Math.floor(Math.random()*2));
    const botH = t*(1 + Math.floor(Math.random()*2));
    // top wall
    obstacles.push(makeBlock(x, 0, t*1.8, topH));
    // bottom wall
    obstacles.push(makeBlock(x, groundY - botH, t*1.8, botH));
    if(i%3===1) coins.push(makeCoin(x + t*0.9, (topH + (groundY - botH))/2));
    x += t*2.1;
  }
  sectionEndX = x + 60;
}

/* Flip section: ceiling filled with blocks & hanging spikes */
function spawnFlipSection(startX){
  const t = G.tile;
  let x = startX;
  const segs = 10;
  const topBand = t*3;
  for(let i=0;i<segs;i++){
    // top blocks (ceiling)
    obstacles.push(makeBlock(x, 0, t*1.8, topBand));
    // hanging spike from ceiling (triangles pointing down)
    if(i%2===0) obstacles.push(makeSpike(x + t*0.2, topBand + t*0.1, t*1.6)); // this spike sits just below the ceiling, treated as normal spike but collision logic handles orientation
    coins.push(makeCoin(x + t*0.9, topBand + t*1.25));
    x += t*2.1;
  }
  sectionEndX = x + 80;
}

/* --------------------
   Spawning controller (time + distance + emergency)
   -------------------- */
let spawnAcc = 0;
function updateSpawning(dt){
  spawnAcc += dt;
  if(!inSection && spawnAcc >= G.spawnBase){
    spawnAcc -= G.spawnBase;
    spawnPatternNormal(W() + 240 + Math.random()*120);
  }

  // random chance to start a section
  if(!inSection && Math.random() < 0.0075){
    inSection = true;
    const startX = W() + 260;
    const kind = Math.random()<0.5 ? 'ship' : 'flip';
    obstacles.push(makePortal(startX - 64, H()/2 - 28, kind));
    if(kind === 'ship') spawnShipSection(startX);
    else spawnFlipSection(startX);
  }

  // finish section when sectionEndX is left of player
  if(inSection && sectionEndX < player.x - 80){
    inSection = false;
    // spawn portal to return to normal mode
    obstacles.push(makePortal(W() + 220, H()/2 - 28, 'normal'));
    sectionEndX = W() + 220 + 120;
  }

  // maintain coin count occasionally
  if(coins.length < 4 && Math.random() < 0.06){
    coins.push(makeCoin(W() + 120 + Math.random()*220, H() - G.floorH - G.tile - 18));
  }
}

/* --------------------
   Collisions & physics
   -------------------- */
function update(dt){
  // update player depending on mode
  if(gameMode === MODE.SHIP){
    // ship: controlled ascent when inputPressed
    if(inputPressed) player.vy += G.shipThrust;
    else player.vy += -G.shipThrust * 0.6; // gentle downward
    player.vy = clamp(player.vy, -9, 9);
    player.y += player.vy;
    player.onGround = false;
    // rotation: tilt slightly with input
    player.rot = lerp(player.rot, inputPressed ? -0.25 : 0.25, 0.12);
  } else {
    // gravity or inverted gravity
    const g = (gameMode === MODE.FLIP) ? -G.gravity : G.gravity;
    player.vy += g * (dt / 16.67);
    player.y += player.vy * (dt / 16.67);
    // rotation rotates in air toward 90deg (pi/2)
    if(!player.onGround) player.rot = lerp(player.rot, Math.PI/2, 0.12);
    else player.rot = lerp(player.rot, 0, 0.2);
  }

  // floor/ceiling constraints
  const floorY = H() - G.floorH - player.h;
  if(gameMode !== MODE.FLIP){
    if(player.y > floorY){ player.y = floorY; player.vy = 0; player.onGround = true; }
    if(player.y < 0){ player.y = 0; player.vy = 0; }
  } else {
    if(player.y < 0){ player.y = 0; player.vy = 0; player.onGround = true; }
    if(player.y > floorY){ player.y = floorY; player.vy = 0; }
  }

  // move obstacles world
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.x -= speed * (dt / 16.67);

    // portal triggers
    if(o.type === 'portal' && !o.triggered){
      if(AABB(player.x,player.y,player.w,player.h, o.x,o.y,o.w,o.h)){
        o.triggered = true;
        if(o.kind === 'ship'){ gameMode = MODE.SHIP; sfx(1180,0.12,'triangle',0.12); }
        else if(o.kind === 'flip'){ gameMode = MODE.FLIP; sfx(720,0.12,'sine',0.12); }
        else { gameMode = MODE.NORMAL; sfx(520,0.12,'sine',0.12); }
      }
    }

    // scoring (pass obstacles)
    if(!o.passed && o.type !== 'portal' && (o.x + (o.w || G.tile*1.6) + 6) < player.x - 8){
      o.passed = true;
      score += 1;
      if(score % 10 === 0) speed = Math.min(G.speedMax, speed + 0.25);
      sfx(1400,0.06,'sine',0.08);
    }

    // remove off-screen
    if(o.x + (o.w || 80) < -360) obstacles.splice(i,1);
  }

  // coins movement & pickup
  for(let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= speed * (dt / 16.67);
    if(c.x < -140){ coins.splice(i,1); continue; }
    if(dist(player.x + player.w/2, player.y + player.h/2, c.x, c.y) < (player.w*0.45 + c.r)){
      coins.splice(i,1); state.coins = (state.coins || 0) + 1; sfx(1600,0.08,'sine',0.12);
      saveState();
    }
  }

  // obstacle collisions
  for(const o of obstacles){
    if(o.type === 'block'){
      resolveBlockCollision(player, o);
    } else if(o.type === 'spike'){
      if(checkSpikeCollision(player, o)) killPlayer();
    }
  }

  // distance
  distance += speed * (dt / 16.67);
}

/* Block collision resolver:
   - If collision is predominantly vertical from top -> stand on block (top collision)
   - If collision is predominantly horizontal (side) -> die
*/
function resolveBlockCollision(p, b){
  if(!AABB(p.x,p.y,p.w,p.h, b.x,b.y,b.w,b.h)) return;
  // compute overlaps
  const leftOverlap = (p.x + p.w) - b.x;
  const rightOverlap = (b.x + b.w) - p.x;
  const topOverlap = (p.y + p.h) - b.y;
  const bottomOverlap = (b.y + b.h) - p.y;
  const minHoriz = Math.min(leftOverlap, rightOverlap);
  const minVert = Math.min(topOverlap, bottomOverlap);
  if(minHoriz < minVert){
    // horizontal collision -> side hit -> die
    killPlayer();
  } else {
    // vertical collision
    if(topOverlap < bottomOverlap){
      // landed on top
      p.y = b.y - p.h;
      p.vy = 0;
      p.onGround = true;
    } else {
      // hit from below (head bump)
      p.y = b.y + b.h;
      p.vy = 0;
    }
  }
}

/* Spike collision: approximate by triangle area test for bottom-pointing spikes.
   For hanging spikes (from ceiling) we placed spike objects at positions where they are intended.
*/
function checkSpikeCollision(p, s){
  // bounding box pre-check
  if(!AABB(p.x,p.y,p.w,p.h, s.x, s.y, s.w, s.h)) return false;
  // test player bottom points
  const pts = [
    {x: p.x + p.w*0.1, y: p.y + p.h},
    {x: p.x + p.w*0.9, y: p.y + p.h},
    {x: p.x + p.w*0.5, y: p.y + p.h}
  ];
  for(const pt of pts){
    if(pointInTri(pt.x, pt.y, s.x, s.y, s.x + s.w/2, s.y - (s.h - 4), s.x + s.w, s.y + s.h)) return true;
    // also test top-facing triangles (for hanging spikes) approximate by flipping
    if(pointInTri(pt.x, pt.y, s.x, s.y, s.x + s.w/2, s.y + s.h + (s.h/1.6), s.x + s.w, s.y)) return true;
  }
  return false;
}
function pointInTri(px,py, ax,ay, bx,by, cx,cy){
  const areaOrig = Math.abs((ax*(by-cy)+bx*(cy-ay)+cx*(ay-by))/2);
  const a1 = Math.abs((px*(by-cy)+bx*(cy-py)+cx*(py-by))/2);
  const a2 = Math.abs((ax*(py-cy)+px*(cy-ay)+cx*(ay-py))/2);
  const a3 = Math.abs((ax*(by-py)+bx*(py-ay)+px*(ay-by))/2);
  return Math.abs((a1+a2+a3) - areaOrig) < 0.5;
}

/* kill player and gameover flow */
function killPlayer(){
  if(!player.alive) return;
  player.alive = false;
  sfx(160,0.22,'sawtooth',0.14);
  if(score > (state.best || 0)) state.best = score;
  saveState();
  // clear world to avoid stacking
  obstacles.length = 0; coins.length = 0; particles.length = 0;
  speed = G.speedBase;
  setTimeout(()=> {
    document.getElementById('goScore').textContent = score;
    document.getElementById('goBest').textContent = state.best || 0;
    document.getElementById('olGO').classList.add('show');
    gameState = 'gameover';
  }, 280);
}

/* --------------------
   Input
   -------------------- */
let inputPressed = false;
function jump(){
  if(gameState === 'menu'){ startGame(); return; }
  if(gameState === 'gameover'){ restartGame(); return; }
  if(gameState !== 'playing') return;

  if(gameMode === MODE.SHIP){
    inputPressed = true; // ship uses hold
  } else if(gameMode === MODE.FLIP){
    if(player.onGround){
      // inverted gravity jump -> push upward from ceiling
      player.vy = -G.jump * 0.7; // tuned
      player.onGround = false;
      sfx(920,0.06,'sine',0.1);
    }
  } else {
    // normal jump - allow when on top of floor or on top of block
    if(player.onGround){
      player.vy = G.jump;
      player.onGround = false;
      sfx(960,0.06,'sine',0.11);
    }
  }
}
function release(){
  if(gameMode === MODE.SHIP) inputPressed = false;
}
document.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); jump(); }
  else if(e.code === 'KeyS'){ toggleShop(); }
  else if(e.code === 'KeyP'){ togglePause(); }
  else if(e.code === 'KeyM'){ initAudio(); toggleMute(); }
  else if(e.code === 'KeyR'){ restartGame(); }
});
document.addEventListener('keyup', e=>{ if(e.code === 'Space' || e.code === 'ArrowUp') release(); });
canvas.addEventListener('pointerdown', ()=>{ jump(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
canvas.addEventListener('pointerup', ()=>{ release(); });
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); jump(); }, {passive:false});

/* --------------------
   Rendering
   -------------------- */
function render(){
  drawBackground();
  drawParallax();

  // tile bands: ceiling and floor
  drawTileBand(0, 3); // ceiling tiles
  drawTileBand(H() - G.floorH, 3); // floor tiles

  // obstacles
  for(const o of obstacles){
    if(o.type === 'block') drawBlock(o);
    else if(o.type === 'spike') drawSpike(o);
    else if(o.type === 'portal') drawPortal(o);
  }

  // coins
  for(const c of coins) drawCoin(c);

  // player
  drawPlayer();

  // particles
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life--;
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0,p.life/40)})`;
    ctx.fillRect(p.x, p.y, 2, 2);
    if(p.life <= 0) particles.splice(i,1);
  }

  // center score
  ctx.font = 'bold 44px Inter, system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(0,0,0,0.36)'; ctx.fillText(score, W()/2 + 3, 72 + 3);
  ctx.fillStyle = '#fff'; ctx.fillText(score, W()/2, 72);

  // HUD DOM update
  document.getElementById('hudScore').textContent = score;
  document.getElementById('hudCoins').textContent = state.coins || 0;
  document.getElementById('hudBest').textContent = state.best || 0;
}

/* --------------------
   Main loop
   -------------------- */
let lastTime = 0;
let gameState = 'menu';
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = Math.min(60, ts - lastTime); lastTime = ts;

  if(gameState === 'playing'){
    update(dt);
    updateSpawning(dt);
  }

  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* --------------------
   Game flow
   -------------------- */
function startGame(){
  initAudio();
  document.getElementById('olMenu').classList.remove('show');
  document.getElementById('olGO').classList.remove('show');
  document.getElementById('olShop').classList.remove('show');
  obstacles = []; coins = []; particles = [];
  score = 0; distance = 0; speed = G.speedBase; spawnAcc = 0; inSection = false; sectionEndX = 0;
  gameMode = MODE.NORMAL;
  player.x = 180; player.y = H() - G.floorH - player.h; player.vy = 0; player.onGround = true; player.alive = true; player.rot = 0;
  // pre-spawn some patterns to give running start
  for(let i=0;i<3;i++) spawnPatternNormal(W() + 240 + i*420);
  gameState = 'playing';
}
function restartGame(){
  document.getElementById('olGO').classList.remove('show');
  startGame();
}
function togglePause(){
  if(gameState === 'playing'){ gameState = 'menu'; document.getElementById('olMenu').classList.add('show'); }
  else if(gameState === 'menu'){ gameState = 'playing'; document.getElementById('olMenu').classList.remove('show'); }
}

/* --------------------
   Shop UI
   -------------------- */
function toggleShop(){
  const ol = document.getElementById('olShop');
  if(ol.classList.contains('show')) { ol.classList.remove('show'); }
  else { buildShop(); ol.classList.add('show'); }
}
function buildShop(){
  const grid = document.getElementById('skinGrid'); grid.innerHTML = '';
  for(const s of skins){
    const card = document.createElement('div'); card.className = 'skin-card';
    const prev = document.createElement('canvas'); prev.width = 240; prev.height = 96; prev.className = 'preview';
    const pctx = prev.getContext('2d');
    pctx.fillStyle = '#071226'; pctx.fillRect(0,0,240,96);
    pctx.fillStyle = s.body; pctx.fillRect(96,24,48,48);
    pctx.strokeStyle = s.accent; pctx.lineWidth = 3; pctx.strokeRect(96,24,48,48);
    const title = document.createElement('div'); title.textContent = `${s.name} ‚Äî ${s.price}ü™ô`; title.style.fontWeight = '700';
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px';
    const btn = document.createElement('button');
    if(state.owned.includes(s.id)){
      btn.textContent = state.active === s.id ? 'Aktiv' : 'W√§hlen';
      btn.className = 'ghost'; btn.disabled = state.active === s.id;
      btn.onclick = ()=>{ state.active = s.id; saveState(); buildShop(); sfx(900,0.06,'sine',0.08); };
    } else {
      btn.textContent = `Kaufen ${s.price}ü™ô`; btn.className = 'cta';
      btn.onclick = ()=>{
        if((state.coins || 0) >= s.price){
          state.coins -= s.price; state.owned.push(s.id); saveState(); buildShop(); sfx(980,0.08,'triangle',0.12);
        } else { sfx(220,0.06,'square',0.1); }
      };
    }
    row.appendChild(btn);
    card.appendChild(prev); card.appendChild(title); card.appendChild(row);
    grid.appendChild(card);
  }
  document.getElementById('shopCoins').textContent = state.coins || 0;
}

/* --------------------
   UI bindings
   -------------------- */
document.getElementById('btnPlay').onclick = ()=> startGame();
document.getElementById('btnOpenShop').onclick = ()=> { document.getElementById('olShop').classList.add('show'); buildShop(); };
document.getElementById('shopClose').onclick = ()=> document.getElementById('olShop').classList.remove('show');
document.getElementById('btnCloseShop').onclick = ()=> document.getElementById('olShop').classList.remove('show');
document.getElementById('btnRestart').onclick = ()=> restartGame();
document.getElementById('btnGoShop').onclick = ()=> { document.getElementById('olGO').classList.remove('show'); document.getElementById('olShop').classList.add('show'); buildShop(); };
document.getElementById('btnPause').onclick = ()=> togglePause();
document.getElementById('btnMute').onclick = ()=> { initAudio(); toggleMute(); };
document.getElementById('btnShop').onclick = ()=> toggleShop();
document.getElementById('btnHelp').onclick = ()=> document.getElementById('olHelp').classList.add('show');
document.getElementById('helpClose').onclick = ()=> document.getElementById('olHelp').classList.remove('show');
document.getElementById('helpOk').onclick = ()=> document.getElementById('olHelp').classList.remove('show');

/* --------------------
   Kickstart values
   -------------------- */
document.getElementById('hudBest').textContent = state.best || 0;
document.getElementById('hudCoins').textContent = state.coins || 0;

/* keep spawn ticking even if loop is heavy */
let spawnAcc = 0;
setInterval(()=>{ if(gameState==='playing') updateSpawning(200); }, 200);

</script>
</body>
</html>
