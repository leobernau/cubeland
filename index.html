<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bernau Games - CubeLand</title>
<style>
  :root{ --panel: rgba(255,255,255,0.04); }
  html,body{ height:100%; margin:0; background:#05060a; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; color:#fff; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  #app{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:18px; box-sizing:border-box; }
  canvas#game{ width:100%; max-width:1400px; height:calc(100vh - 36px); max-height:820px; border-radius:12px; background:linear-gradient(180deg,#05060a,#081023); box-shadow:0 30px 80px rgba(0,0,0,0.7); display:block; }
  .hud{ position:absolute; left:22px; top:18px; display:flex; gap:8px; z-index:40; align-items:center; }
  .pill{ background:rgba(255,255,255,0.03); padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.03); display:flex; gap:10px; align-items:center; font-weight:700; }
  .right-hud{ position:absolute; right:22px; top:18px; display:flex; gap:8px; z-index:40; }
  .icon{ width:44px; height:36px; display:grid; place-items:center; background:rgba(255,255,255,0.02); border-radius:8px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); user-select:none; }
  .icon:active{ transform:scale(.98); }
  .overlay{ position:absolute; inset:0; display:grid; place-items:center; z-index:80; background:linear-gradient(180deg, rgba(2,6,23,0.75), rgba(2,6,23,0.75)); }
  .card{ background:rgba(255,255,255,0.03); padding:18px; border-radius:12px; width:min(92vw,900px); box-shadow:0 20px 60px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03); color:#fff; }
  .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
  button.cta{ background:linear-gradient(90deg,#7c3aed,#06b6d4); border:none; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer; color:#fff; }
  button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.08); padding:8px 10px; border-radius:8px; cursor:pointer; color:#fff; }
  .close-x{ position:absolute; right:12px; top:12px; background:rgba(255,255,255,0.03); border-radius:999px; padding:8px; cursor:pointer; }
  .shop-grid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px; max-height:48vh; overflow:auto; padding:8px; }
  .skin-card{ background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; display:flex; flex-direction:column; gap:8px; align-items:center; border:1px solid rgba(255,255,255,0.02); }
  .preview{ width:120px; height:70px; border-radius:8px; display:grid; place-items:center; overflow:hidden; }
  .muted{ opacity:0.85; font-size:13px; }
  .small{ font-size:12px; opacity:0.8; }
  @media (max-width:640px){ canvas#game{ height:calc(100vh - 24px); border-radius:8px; } .card{ width:94vw; } }
</style>
</head>
<body>
  <div id="app">
    <canvas id="game" width="1280" height="720" role="img" aria-label="Bernau Games - CubeLand"></canvas>

    <div class="hud" aria-hidden="false">
      <div class="pill">🎮 Bernau Games - CubeLand</div>
      <div class="pill">🪙 <span id="hudCoins">0</span></div>
      <div class="pill">🏆 Best: <span id="hudBest">0</span></div>
      <div class="pill">📏 Score: <span id="hudScore">0</span></div>
    </div>

    <div class="right-hud">
      <div class="icon" id="btnPause" title="Pause (P)">⏸</div>
      <div class="icon" id="btnMute" title="Mute (M)">🔊</div>
      <div class="icon" id="btnShop" title="Shop (S)">🛍️</div>
      <div class="icon" id="btnHelp" title="Hilfe (H)">❓</div>
    </div>

    <div id="overlayMenu" class="overlay" role="dialog" aria-modal="true">
      <div class="card">
        <div class="row">
          <h1 style="margin:0">Bernau Games - CubeLand</h1>
          <div class="small muted">Geometry Dash inspired</div>
        </div>
        <p style="margin-top:10px">Springe über Hindernisse, durch Portale, sammle Münzen und schalte Skins frei. Endlosmodus: wie weit kommst du?</p>
        <div class="row" style="margin-top:12px">
          <div>
            <button class="cta" id="startButton">▶️ Spielen</button>
            <button class="ghost" id="openShopButton">🛍️ Shop</button>
          </div>
          <div style="text-align:right">
            <div class="muted">Steuerung: Leertaste/Tap = Springen · P = Pause · S = Shop · M = Ton · R = Neustart</div>
          </div>
        </div>
        <div style="margin-top:10px" class="small">Speichert Fortschritt lokal (localStorage).</div>
      </div>
    </div>

    <div id="overlayGameOver" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card">
        <h2 style="margin:0">Game Over</h2>
        <p class="muted">Dein Score: <b id="goScore">0</b> · Best: <b id="goBest">0</b></p>
        <div class="row" style="margin-top:12px">
          <button class="cta" id="btnRestart">↺ Neustarten (R)</button>
          <button class="ghost" id="btnGoShop">🛍️ Shop</button>
        </div>
      </div>
    </div>

    <div id="overlayShop" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="position:relative;">
        <div class="close-x" id="shopClose">✕</div>
        <h2 style="margin:0 0 6px 0">Shop — Skins</h2>
        <p class="muted">Kaufe Skins mit Münzen. Skins sind erst aktivierbar, wenn gekauft.</p>

        <h3 style="margin-top:12px; margin-bottom:6px">Skins</h3>
        <div id="skinGrid" class="shop-grid" aria-live="polite"></div>

        <div class="row" style="margin-top:12px;">
          <div class="muted">Deine Münzen: <b id="shopCoins">0</b></div>
          <div><button class="ghost" id="shopCloseBtn">Schließen</button></div>
        </div>
      </div>
    </div>

    <div id="overlayHelp" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="max-width:560px">
        <div class="close-x" id="helpClose">✕</div>
        <h2>Hilfe</h2>
        <p>Springe über Hindernisse und Stacheln. Manche Portale verändern dein Verhalten (Boost/Flip/Ship). Münzen liegen oft auf Plattformen.</p>
        <div style="text-align:center; margin-top:8px"><button class="cta" id="helpOk">Verstanden</button></div>
      </div>
    </div>

  </div>

<script>
/* ============================================================================
   Aktualisierte Version: Endlos-Spawning & Score-Fix
   - Ziel: niemals "stehen bleiben", Score kann unendlich wachsen
   ============================================================================ */

/* -------------------------
   Persistence
   ------------------------- */
const LS_KEY = 'bernau_cubeland_state_v1';
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY) || '{}');
    s.coins = s.coins || 0;
    s.best = s.best || 0;
    s.owned = s.owned || ['skin_default'];
    s.active = s.active || 'skin_default';
    s.muted = typeof s.muted === 'boolean' ? s.muted : false;
    return s;
  }catch(e){
    return { coins:0, best:0, owned:['skin_default'], active:'skin_default', muted:false };
  }
}
function saveState(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){} }

let state = loadState();

/* -------------------------
   Canvas
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

function fitCanvas(){
  const parentRect = canvas.parentElement.getBoundingClientRect();
  let w = Math.min(parentRect.width, 1400);
  let h = Math.min(parentRect.height, 820);
  const targetRatio = 16/9;
  if(w / h > targetRatio) { w = Math.round(h * targetRatio); }
  else { h = Math.round(w / targetRatio); }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();
function W(){ return canvas.width / DPR; }
function H(){ return canvas.height / DPR; }

/* -------------------------
   Game variables
   ------------------------- */
let gameState = 'menu';
let score = 0;
let distance = 0;
let speed = 3.6;
let gravity = 0.6;
let jumpPower = -10;
let lastTime = 0;

/* Player */
let player = { x:180, y:H()/2, vy:0, w:44, h:44, rotation:0, alive:true, onGround:false, jumpCount:0 };

/* Worlds */
let obstacles = [];
let coins = [];
let particles = [];

/* Spawning control (robust) */
let spawnTimer = 0;
let spawnInterval = 850; // base interval in ms
let forcedSpawnCooldown = 0;

/* Skins — explicit */
let skins = [];
function addSkin(id,name,shape,body,accent,price){ skins.push({id,name,shape,body,accent,price}); }
addSkin('skin_default','Default','cube','#ffd54f','#f59e0b',0);
addSkin('skin_neon','Neon Pulse','cube','#7c3aed','#00f6ff',30);
addSkin('skin_glow','Glow','rounded','#06b6d4','#7c3aed',45);
addSkin('skin_steel','Steel','cube','#9CA3AF','#6B7280',50);
addSkin('skin_ship','Ship','ship','#F472B6','#FB7185',80);
if(!state.owned.includes('skin_default')) state.owned.push('skin_default');
if(!state.active || !skins.find(s=>s.id===state.active)) state.active = 'skin_default';

/* Background config */
const bg = { top:'#02040a', bottom:'#061226', neon1:'#06b6d4', neon2:'#7c3aed' };

/* Audio simplified */
let audioCtx = null, masterGain = null;
function initAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); masterGain = audioCtx.createGain(); masterGain.connect(audioCtx.destination); masterGain.gain.value = state.muted?0:0.9; buildMusic(); }catch(e){ console.warn('Audio init failed', e); } }
function buildMusic(){ if(!audioCtx) return; const bgGain = audioCtx.createGain(); bgGain.gain.value = 0.04; bgGain.connect(masterGain); const o1 = audioCtx.createOscillator(); o1.type='sine'; o1.frequency.value=110; o1.connect(bgGain); o1.start(); const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value=220; o2.connect(bgGain); o2.start(); const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.09; const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.03; lfo.connect(lfoGain); lfoGain.connect(bgGain.gain); lfo.start(); }
function toggleMute(){ state.muted = !state.muted; if(masterGain) masterGain.gain.value = state.muted?0:0.9; document.getElementById('btnMute').textContent = state.muted ? '🔈' : '🔊'; saveState(); }
function playSfx(freq,dur,type,vol){ if(!audioCtx || state.muted) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = vol; o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime + dur); }

/* Utilities */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rectOverlap(ax,ay,aw,ah,bx,by,bw,bh){ return !(ax+aw < bx || bx+bw < ax || ay+ah < by || by+bh < ay); }
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }

/* Obstacle constructors (explicit) */
function makeBlock(x,top,w=80,gap=160){ return { type:'block', x:x, top:top, w:w, gap:gap }; }
function makeSpikeRow(x,y,count,spacing){ return { type:'spikes', x:x, y:y, count:count, spacing:spacing, w:count*spacing }; }
function makeMovingBlock(x,top,h,vy){ return { type:'moving', x:x, top:top, h:h, w:72, vy:vy, dir:1 }; }
function makePortal(x,y,ptype){ return { type:'portal', x:x, y:y, w:64, portalType:ptype, triggered:false }; }

/* Spawn single segment (explicit variations) */
function spawnSegmentAt(x){
  const r = Math.random();
  if(r < 0.22){
    const top = Math.floor(rand(100, H() - 260));
    obstacles.push(makeBlock(x, top, 80, 160));
    obstacles.push(makeBlock(x, top + 180, 80, 160));
    coins.push({ x: x + 40, y: top + 80, r: 10, taken:false });
  } else if(r < 0.42){
    const top = Math.floor(rand(120, H() - 220));
    obstacles.push(makeMovingBlock(x, top, 80, rand(0.6,1.2)));
    coins.push({ x: x + 28, y: top - 24, r: 10, taken:false });
  } else if(r < 0.58){
    const y = H() - 60 - 12;
    obstacles.push(makeSpikeRow(x, y, Math.floor(rand(3,7)), 24));
  } else if(r < 0.76){
    const y = Math.floor(rand(120, H() - 200));
    obstacles.push(makePortal(x, y, (Math.random()<0.5)?'ship':(Math.random()<0.5?'flip':'boost')));
    coins.push({ x: x + 36, y: y + 16, r: 10, taken:false });
  } else {
    const top = Math.floor(rand(80, H() - 240));
    obstacles.push(makeBlock(x, top, 96, 220));
    obstacles.push(makeBlock(x, top + 220, 96, 220));
    coins.push({ x: x + 44, y: top + 110, r: 10, taken:false });
  }
}

/* Robust spawn updater:
   - time based spawnTimer
   - distance/space based spawn when rightmost obstacle is near
   - immediate spawn if obstacles empty
*/
function updateSpawn(dt){
  // reduce forcedSpawnCooldown to avoid spamming
  forcedSpawnCooldown = Math.max(0, forcedSpawnCooldown - dt);

  // time-based spawn
  spawnTimer += dt;
  if(spawnTimer >= spawnInterval){
    spawnTimer -= spawnInterval;
    const baseX = W() + 80 + Math.random()*220;
    spawnSegmentAt(baseX);
  }

  // ensure there's always enough obstacles ahead
  if(obstacles.length === 0 && forcedSpawnCooldown <= 0){
    // immediate spawn 3 segments to fill
    for(let i=0;i<3;i++){
      spawnSegmentAt(W() + 160 + i*380);
    }
    forcedSpawnCooldown = 500; // 0.5s cooldown
  } else {
    // find rightmost obstacle's x
    let rightmost = -Infinity;
    for(const o of obstacles) if(o.x > rightmost) rightmost = o.x;
    // If rightmost is nearer than threshold, spawn ahead
    const threshold = W() - 260;
    if(rightmost < threshold && forcedSpawnCooldown <= 0){
      spawnSegmentAt(W() + 240);
      forcedSpawnCooldown = 220; // small cooldown
    }
  }

  // also spawn based on coins count to ensure coins don't vanish from screen too early
  if(coins.length < 3 && Math.random() < 0.06){
    coins.push({ x: W() + 140 + Math.random()*220, y: rand(120, H()-200), r:10, taken:false });
  }
}

/* Update loop (physics and collision) */
function update(dt){
  if(gameState !== 'playing') return;

  // apply gravity & movement
  player.vy += gravity * (dt / 16.67);
  player.y += player.vy * (dt / 16.67);
  player.rotation = clamp(player.vy * 0.03, -0.9, 1.6);

  // ground check
  const groundY = H() - 60 - player.h/2;
  if(player.y > groundY){
    player.y = groundY; player.vy = 0; player.onGround = true; player.jumpCount = 0;
  } else { player.onGround = false; }

  // move obstacles and check collisions
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.x -= speed * (dt / 16.67);

    // moving block vertical behavior
    if(o.type === 'moving'){
      o.top += o.vy * o.dir * (dt / 16.67);
      if(o.top < 60 || o.top + (o.h||80) > H() - 120) o.dir *= -1;
    }

    // portal triggers
    if(o.type === 'portal'){
      const px = o.x + o.w/2;
      const py = o.y + 32;
      if(Math.abs(player.x - px) < o.w/2 + player.w/2 && Math.abs(player.y - py) < 40 && !o.triggered){
        o.triggered = true;
        if(o.portalType === 'ship'){ player.vy = -6; playSfx(1100,0.12,'sine',0.12); }
        else if(o.portalType === 'boost'){ speed += 1.6; setTimeout(()=>{ speed = Math.max(3.6, speed - 1.6); }, 1600); playSfx(920,0.12,'sawtooth',0.12); }
        else if(o.portalType === 'flip'){ gravity = -gravity; setTimeout(()=>{ gravity = -gravity; }, 1600); playSfx(520,0.14,'triangle',0.1); }
      }
    }

    // collisions
    if(o.type === 'block' || o.type === 'moving'){
      const topRect = { x:o.x, y:0, w:o.w || 80, h:o.top };
      const bottomY = o.top + (o.gap || 160);
      const bottomRect = { x:o.x, y:bottomY, w:o.w || 80, h: H() - bottomY - 60 };
      const px = player.x - player.w/2, py = player.y - player.h/2, pw = player.w, ph = player.h;

      if(rectOverlap(px,py,pw,ph, topRect.x, topRect.y, topRect.w, topRect.h) ||
         rectOverlap(px,py,pw,ph, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)){
        playerDie();
      }
    } else if(o.type === 'spikes'){
      const spikeRect = { x:o.x, y:o.y - 20, w:o.w, h:20 };
      const px = player.x - player.w/2, py = player.y - player.h/2, pw = player.w, ph = player.h;
      if(rectOverlap(px,py,pw,ph, spikeRect.x, spikeRect.y, spikeRect.w, spikeRect.h)){
        playerDie();
      }
    }

    // remove offscreen obstacles (very far left)
    if(o.x + (o.w || 80) < -240) obstacles.splice(i,1);
  }

  // update coins
  for(let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= speed * (dt / 16.67);
    if(!c.taken && dist(c.x,c.y,player.x,player.y) < c.r + (player.w/2) - 6){
      c.taken = true;
      state.coins = (state.coins || 0) + 1;
      playSfx(1200,0.08,'sine',0.1);
      for(let p=0;p<8;p++) particles.push({ x:c.x, y:c.y, vx: rand(-1.6,1.6), vy: rand(-3,-1), life: 50 + Math.random()*20 });
      coins.splice(i,1);
    } else if(c.x < -80) coins.splice(i,1);
  }

  // particles
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx * (dt / 16.67); p.y += p.vy * (dt / 16.67);
    p.vy += 0.12; p.life -= dt / 16.67;
    if(p.life <= 0) particles.splice(i,1);
  }

  // update distance & score (unbounded)
  distance += speed * (dt / 16.67);
  score = Math.floor(distance / 5); // more granular score (can grow quickly)

  // spawn management (robust)
  updateSpawn(dt);
}

/* Rendering — neon/dark */
function render(){
  ctx.clearRect(0,0,W(),H());

  // background
  const g = ctx.createLinearGradient(0,0,0,H());
  g.addColorStop(0, '#02040a'); g.addColorStop(1, '#061226');
  ctx.fillStyle = g; ctx.fillRect(0,0,W(),H());

  // neon grid
  drawNeonBackground();

  // ground
  ctx.fillStyle = '#0b1220'; ctx.fillRect(0, H()-60, W(), 60);
  for(let i=0;i<Math.ceil(W()/30)+3;i++){ const x = (i*30 - (Math.floor(distance)%30)); ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(x, H()-24, 14, 6); }

  // obstacles
  for(const o of obstacles){
    if(o.type === 'block' || o.type === 'moving'){
      ctx.fillStyle = '#102b2a'; ctx.fillRect(o.x, 0, o.w || 80, o.top);
      ctx.fillStyle = '#0f5b56'; ctx.fillRect(o.x-6, o.top-16, (o.w||80)+12, 16);
      const bottomY = o.top + (o.gap || 160);
      ctx.fillStyle = '#102b2a'; ctx.fillRect(o.x, bottomY, (o.w||80), H()-bottomY-60);
      ctx.fillStyle = '#0f5b56'; ctx.fillRect(o.x-6, bottomY, (o.w||80)+12, 16);

      ctx.strokeStyle = 'rgba(96,165,250,0.16)'; ctx.lineWidth = 2;
      ctx.strokeRect(o.x, 0, o.w || 80, o.top); ctx.strokeRect(o.x, bottomY, o.w || 80, H()-bottomY-60);

      if(o.type === 'moving'){ ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(o.x+2, o.top+2, o.w-4, (o.h||80)-4); }
    } else if(o.type === 'portal'){
      const centerX = o.x + o.w/2, centerY = o.y + 32;
      ctx.save();
      ctx.beginPath(); ctx.arc(centerX, centerY, 28, 0, Math.PI*2);
      ctx.fillStyle = o.portalType === 'ship' ? '#ffd54f' : o.portalType === 'flip' ? '#8b5cf6' : '#60a5fa';
      ctx.fill();
      ctx.beginPath(); ctx.arc(centerX, centerY, 14, 0, Math.PI*2); ctx.fillStyle = '#061226'; ctx.fill();
      ctx.restore();
      ctx.beginPath(); ctx.arc(centerX, centerY, 28, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 2; ctx.stroke();
    } else if(o.type === 'spikes'){
      ctx.fillStyle = '#c62828';
      for(let i=0;i<o.count;i++){
        const sx = o.x + i*o.spacing;
        ctx.beginPath(); ctx.moveTo(sx, o.y); ctx.lineTo(sx + (o.spacing/2), o.y - 18); ctx.lineTo(sx + o.spacing, o.y); ctx.closePath(); ctx.fill();
      }
    }
  }

  // coins
  for(const c of coins){
    ctx.save(); ctx.translate(c.x, c.y); const rot = Math.sin(Date.now()*0.003 + c.x*0.002) * 0.4; ctx.rotate(rot);
    ctx.fillStyle = '#f6c84c'; ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff1a8'; ctx.beginPath(); ctx.arc(-c.r*0.25, -c.r*0.25, c.r*0.45, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  // player (neon cube)
  drawPlayer(player);

  // particles
  for(const p of particles){ ctx.fillStyle = `rgba(255,255,255,${Math.max(0,p.life/60)})`; ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(1,p.life*0.03), 0, Math.PI*2); ctx.fill(); }

  // big center score
  ctx.font = 'bold 42px Inter, system-ui, sans-serif'; ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.textAlign = 'center'; ctx.fillText(score, W()/2 + 3, 74 + 3); ctx.fillStyle = '#fff'; ctx.fillText(score, W()/2, 74);

  // update HUD DOM
  document.getElementById('hudCoins').textContent = state.coins || 0;
  document.getElementById('hudBest').textContent = state.best || 0;
  document.getElementById('hudScore').textContent = score;
}

function drawNeonBackground(){
  const t = Date.now();
  ctx.save(); ctx.globalAlpha = 0.06; for(let i=0;i<6;i++){ const cx = ((t*0.02) + i*220) % (W()+400) - 200; const cy = 80 + (i%2)*30; ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.ellipse(cx, cy, 68, 26, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(cx+36, cy+10, 42, 18, 0, 0, Math.PI*2); ctx.fill(); } ctx.restore();
}

function drawPlayer(p){
  ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation || 0);
  const skin = skins.find(s => s.id === state.active) || skins[0];
  const size = Math.max(16, p.w * 0.95);
  // body
  ctx.fillStyle = skin.body; roundRect(ctx, -size/2, -size/2, size, size, (skin.shape==='rounded')?8:2); ctx.fill();
  ctx.strokeStyle = skin.accent; ctx.lineWidth = 3; ctx.stroke();
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(size*0.18, -size*0.12, Math.max(2, size*0.08), 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(size*0.22, -size*0.12, Math.max(1.1, size*0.04), 0, Math.PI*2); ctx.fill();
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* Jump / input */
function jump(){
  if(gameState === 'menu'){ startPlaying(); return; }
  if(gameState === 'gameover'){ restartGame(); return; }
  if(gameState !== 'playing') return;
  if(player.onGround || player.jumpCount < 1){
    player.vy = jumpPower; player.onGround = false; player.jumpCount++;
    playSfx(880 + Math.random()*160, 0.06, 'sine', 0.12);
    for(let i=0;i<6;i++) particles.push({ x: player.x - 10 + Math.random()*20, y: player.y + player.h/2, vx: rand(-1.8,1.8), vy: rand(-3,-1), life: 40 + Math.random()*20 });
  }
}

/* player death & restart */
function playerDie(){
  if(!player.alive) return;
  player.alive = false; playSfx(150, 0.2, 'sawtooth', 0.14);
  gameState = 'gameover';
  setTimeout(()=>{ document.getElementById('overlayGameOver').style.display = 'grid'; document.getElementById('goScore').textContent = score; document.getElementById('goBest').textContent = Math.max(state.best || 0, score); }, 300);
  if(!state.best || score > state.best) state.best = score;
  saveState();
}

function restartGame(){
  document.getElementById('overlayGameOver').style.display = 'none';
  player.x = 180; player.y = H()/2; player.vy = 0; player.rotation = 0; player.alive = true; player.onGround = false; player.jumpCount = 0;
  obstacles = []; coins = []; particles = []; spawnTimer = 0; spawnInterval = 850; distance = 0; score = 0; speed = 3.6; gravity = Math.abs(gravity);
  gameState = 'playing';
  for(let i=0;i<4;i++) spawnSegmentAt(W() + i*420);
}

/* Controls */
document.addEventListener('keydown',(e)=>{ if(e.repeat) return; if(e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); jump(); } else if(e.code==='KeyS'){ const el=document.getElementById('overlayShop'); el.style.display = (el.style.display === 'grid' ? 'none' : 'grid'); if(el.style.display === 'grid') buildShopUI(); } else if(e.code==='KeyP'){ if(gameState==='playing'){ gameState='paused'; document.getElementById('overlayMenu').style.display='grid'; } else if(gameState==='paused'){ gameState='playing'; document.getElementById('overlayMenu').style.display='none'; } } else if(e.code==='KeyM'){ initAudio(); toggleMute(); } else if(e.code==='KeyR'){ restartGame(); } else if(e.code==='Escape'){ document.getElementById('overlayMenu').style.display='none'; document.getElementById('overlayShop').style.display='none'; document.getElementById('overlayHelp').style.display='none'; } });
canvas.addEventListener('pointerdown', (e)=>{ jump(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); }, { passive:false });

/* Shop UI */
function buildShopUI(){
  const grid = document.getElementById('skinGrid'); grid.innerHTML = '';
  for(const s of skins){
    const card = document.createElement('div'); card.className='skin-card';
    const preview = document.createElement('div'); preview.className='preview';
    const pv = document.createElement('canvas'); pv.width=240; pv.height=140; pv.style.width='100%'; pv.style.height='100%';
    const pctx = pv.getContext('2d');
    pctx.fillStyle = '#09111a'; pctx.fillRect(0,0,240,140);
    pctx.fillStyle = s.body;
    if(s.shape === 'cube'){ pctx.fillRect(80,30,80,80); }
    else if(s.shape === 'rounded'){ pctx.beginPath(); pctx.ellipse(120,70,40,36,0,0,2*Math.PI); pctx.fill(); }
    else if(s.shape === 'ship'){ pctx.beginPath(); pctx.moveTo(60,70); pctx.lineTo(180,50); pctx.lineTo(60,90); pctx.closePath(); pctx.fill(); }
    else pctx.fillRect(80,30,80,80);
    preview.appendChild(pv); card.appendChild(preview);
    const label = document.createElement('div'); label.className='muted'; label.textContent = s.name + ' — ' + s.price + ' 🪙'; card.appendChild(label);
    const controls = document.createElement('div'); controls.style.display='flex'; controls.style.gap='8px';
    const btn = document.createElement('button');
    if(state.owned.includes(s.id)){ btn.textContent = state.active === s.id ? 'Aktiv' : 'Wählen'; btn.className='ghost'; btn.disabled = state.active === s.id; btn.addEventListener('click', ()=>{ state.active = s.id; saveState(); buildShopUI(); }); }
    else { btn.textContent = `Kaufen ${s.price}🪙`; btn.className='cta'; btn.addEventListener('click', ()=>{ if(state.coins >= s.price){ state.coins -= s.price; state.owned.push(s.id); saveState(); buildShopUI(); playSfx(880,0.08,'triangle',0.12); } else { document.getElementById('hudCoins').animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:320}); playSfx(220,0.06,'square',0.08); } }); }
    controls.appendChild(btn); card.appendChild(controls); grid.appendChild(card);
  }
  document.getElementById('shopCoins').textContent = state.coins || 0;
}

/* Loop orchestration (explicit) */
let req = null;
function loop(timestamp){
  if(!lastTime) lastTime = timestamp;
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  if(gameState === 'playing'){ update(dt); }
  else if(gameState === 'menu'){ player.y = H()/2 + Math.sin(timestamp*0.002) * 8; }
  else if(gameState === 'gameover'){ /* fall animation handled */ }

  render();
  req = requestAnimationFrame(loop);
}
req = requestAnimationFrame(loop);

/* audio init on user gesture */
function initAudioOnUser(){ initAudio(); document.removeEventListener('pointerdown', initAudioOnUser); }
document.addEventListener('pointerdown', initAudioOnUser);

/* UI wiring */
document.getElementById('startButton').addEventListener('click', ()=>{ startPlaying(); });
document.getElementById('openShopButton').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display='grid'; buildShopUI(); });
document.getElementById('shopClose').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display='none'; });
document.getElementById('shopCloseBtn').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display='none'; });
document.getElementById('btnShop').addEventListener('click', ()=>{ const el=document.getElementById('overlayShop'); el.style.display = (el.style.display === 'grid') ? 'none' : 'grid'; if(el.style.display === 'grid') buildShopUI(); });
document.getElementById('btnMute').addEventListener('click', ()=>{ initAudio(); toggleMute(); });
document.getElementById('btnPause').addEventListener('click', ()=>{ if(gameState === 'playing'){ gameState='paused'; document.getElementById('overlayMenu').style.display='grid'; } else { gameState='playing'; document.getElementById('overlayMenu').style.display='none'; }});
document.getElementById('btnHelp').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='grid'; });
document.getElementById('helpClose').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('helpOk').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('btnRestart')?.addEventListener('click', ()=>{ restartGame(); });
document.getElementById('btnGoShop')?.addEventListener('click', ()=>{ document.getElementById('overlayGameOver').style.display='none'; document.getElementById('overlayShop').style.display='grid'; buildShopUI(); });
document.getElementById('closeIntroBtn')?.addEventListener('click', ()=>{ document.getElementById('overlayMenu').style.display='none'; startPlaying(); });

/* start playing function */
function startPlaying(){
  initAudio();
  document.getElementById('overlayMenu').style.display='none';
  document.getElementById('overlayShop').style.display='none';
  document.getElementById('overlayGameOver').style.display='none';
  player.x = 180; player.y = H()/2; player.vy = 0; player.alive = true; player.jumpCount = 0; player.onGround = false;
  obstacles = []; coins = []; particles = []; spawnTimer = 0; spawnInterval = 850; distance = 0; score = 0; speed = 3.6;
  for(let i=0;i<4;i++) spawnSegmentAt(W() + i*420);
  gameState = 'playing';
}

/* save on unload */
window.addEventListener('beforeunload', ()=>{ saveState(); });

/* set HUD initial */
document.getElementById('hudCoins').textContent = state.coins || 0;
document.getElementById('hudBest').textContent = state.best || 0;
document.getElementById('hudScore').textContent = 0;

</script>
</body>
</html>
