<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bernau Games - CubeLand</title>
<style>
  /* ---------------------------
     Grundlayout & Canvas
     --------------------------- */
  html,body{ height:100%; margin:0; background:#071327; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:#fff; }
  #app{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:18px; box-sizing:border-box; }
  canvas#game{ width:100%; max-width:1400px; height:calc(100vh - 36px); max-height:860px; border-radius:12px; background:linear-gradient(180deg,#87d3ff,#bfe9ff); display:block; box-shadow:0 40px 90px rgba(2,6,23,0.6);}
  /* ---------------------------
     HUD
     --------------------------- */
  .hud{ position:absolute; top:20px; left:20px; display:flex; gap:10px; z-index:40; align-items:center; }
  .pill{ background:rgba(0,0,0,0.35); padding:8px 12px; border-radius:999px; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,0.04); font-weight:700; display:flex; gap:10px; align-items:center; }
  .right-hud{ position:absolute; top:20px; right:20px; display:flex; gap:8px; z-index:40; }
  .icon{ width:44px; height:36px; display:grid; place-items:center; background:rgba(255,255,255,0.04); border-radius:8px; cursor:pointer; user-select:none; border:1px solid rgba(255,255,255,0.03); }
  .icon:active{ transform:scale(0.98); }
  /* ---------------------------
     Overlays (menu, shop, gameover)
     --------------------------- */
  .overlay{ position:absolute; inset:0; display:grid; place-items:center; z-index:60; background:linear-gradient(180deg, rgba(1,6,23,0.6), rgba(1,6,23,0.6)); }
  .card{ background:rgba(255,255,255,0.03); border-radius:14px; padding:18px; width:min(92vw,920px); box-shadow:0 20px 60px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03); color:#fff; }
  .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
  button.cta{ background:linear-gradient(90deg,#ffd54f,#ffb86b); border:none; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer; }
  button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.08); padding:8px 10px; border-radius:8px; cursor:pointer; color:#fff; }
  .close-x{ position:absolute; right:12px; top:12px; background:rgba(255,255,255,0.06); border-radius:999px; padding:8px; cursor:pointer; }
  /* scrollable shop elements */
  .shop-grid{ display:grid; grid-template-columns: repeat(auto-fill,minmax(180px,1fr)); gap:12px; margin-top:12px; max-height:48vh; overflow:auto; padding-right:8px; }
  .skin-card{ background:rgba(0,0,0,0.25); border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:8px; align-items:center; border:1px solid rgba(255,255,255,0.04); }
  .preview{ width:120px; height:70px; border-radius:8px; display:grid; place-items:center; background:linear-gradient(180deg,rgba(255,255,255,0.02), rgba(255,255,255,0.01)); overflow:hidden; }
  .muted{ opacity:0.8; font-size:13px; }
  .small{ font-size:12px; opacity:0.85; }
  /* responsive */
  @media (max-width:640px){ canvas#game{ height:calc(100vh - 24px); border-radius:6px; } .card{ width:94vw; } }
</style>
</head>
<body>
  <div id="app">
    <canvas id="game" width="1280" height="720" role="img" aria-label="Bernau Games - CubeLand Spiel"></canvas>

    <!-- HUD -->
    <div class="hud" aria-hidden="false">
      <div class="pill">üéÆ Bernau Games - CubeLand</div>
      <div class="pill">ü™ô <span id="hudCoins">0</span></div>
      <div class="pill">üèÜ Highscore: <span id="hudHigh">0</span></div>
      <div class="pill">üìè Score: <span id="hudScore">0</span></div>
    </div>

    <div class="right-hud">
      <div class="icon" id="btnPause" title="Pause (P)">‚è∏</div>
      <div class="icon" id="btnMute" title="Mute (M)">üîä</div>
      <div class="icon" id="btnShop" title="Shop (S)">üõçÔ∏è</div>
      <div class="icon" id="btnHelp" title="Hilfe (H)">‚ùì</div>
    </div>

    <!-- Intro -->
    <div id="overlayMenu" class="overlay" role="dialog" aria-modal="true">
      <div class="card">
        <div class="row">
          <h1 style="margin:0">Bernau Games - CubeLand</h1>
          <div class="small muted">Version 1.0</div>
        </div>
        <p>Endloser Runner im Geometry Dash Stil. Spring, fliege durch Portale, sammle M√ºnzen und schalte Skins frei.</p>
        <div class="row" style="margin-top:10px;">
          <div>
            <button class="cta" id="startButton">‚ñ∂Ô∏è Spielen</button>
            <button class="ghost" id="openShopButton">üõçÔ∏è Shop</button>
          </div>
          <div style="text-align:right">
            <div class="muted">Steuerung: Leertaste/Tap = Springen ¬∑ P = Pause ¬∑ S = Shop ¬∑ M = Ton ¬∑ R = Neustart</div>
          </div>
        </div>
        <div class="small" style="margin-top:10px">Speichert Fortschritt lokal (localStorage).</div>
      </div>
    </div>

    <!-- Game Over -->
    <div id="overlayGameOver" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card">
        <h2 style="margin:0">Game Over</h2>
        <p>Dein Score: <b id="goScore">0</b> ¬∑ Best: <b id="goBest">0</b></p>
        <div class="row" style="margin-top:10px;">
          <button class="cta" id="btnRestart">‚Ü∫ Neustarten (R)</button>
          <button class="ghost" id="btnGoShop">üõçÔ∏è Shop</button>
        </div>
      </div>
    </div>

    <!-- Shop -->
    <div id="overlayShop" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="position:relative;">
        <div class="close-x" id="shopClose">‚úï</div>
        <h2 style="margin:0 0 6px 0">Shop ‚Äî Skins & Extras</h2>
        <p class="muted">Kaufe Skins mit M√ºnzen und schalte kosmetische Effekte frei. Skins sind nur aktivierbar, wenn gekauft.</p>

        <h3 style="margin-top:12px;margin-bottom:6px">Vogel-Skins</h3>
        <div id="skinGrid" class="shop-grid" aria-live="polite"></div>

        <h3 style="margin-top:12px;margin-bottom:6px">Hintergrund-Skins</h3>
        <div id="bgGrid" class="shop-grid"></div>

        <div class="row" style="margin-top:12px;">
          <div class="muted">Deine M√ºnzen: <b id="shopCoins">0</b></div>
          <div><button class="ghost" id="shopCloseBtn">Schlie√üen</button></div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div id="overlayHelp" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="max-width:560px">
        <div class="close-x" id="helpClose">‚úï</div>
        <h2>Hilfe</h2>
        <p>Springe √ºber Hindernisse. Durchlaufe Portale: manche machen dich kurzzeitig zum Flugzeug, andere drehen die Schwerkraft um oder geben einen Geschwindigkeits-Boost.</p>
        <p>Jede gelaufene Strecke erh√∂ht den Score; M√ºnzen liegen in speziellen Plattformen oder nach schweren Hindernissen.</p>
        <div style="text-align:center; margin-top:8px"><button class="cta" id="helpOk">Alles klar</button></div>
      </div>
    </div>
  </div>

<script>
/* ============================================================================
   Bernau Games ‚Äî CubeLand
   Geometry Dash style runner ‚Äî single file
   Features (summary):
   - infinite procedural level, obstacles, portals
   - score & highscore (localStorage)
   - coins & shop (S toggles shop, buy skins)
   - WebAudio generated background music + SFX
   - parallax backgrounds, particles, visual polish
   - controls: space / click / tap to jump; P pause; M mute; R restart; S shop
   ============================================================================ */

/* -----------------------------
   Persistence keys & helpers
   ----------------------------- */
const LS_KEY = 'bernau_cubeland_v1';
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
    s.coins = s.coins || 0;
    s.best = s.best || 0;
    s.owned = s.owned || ["skin_basic"];
    s.active = s.active || "skin_basic";
    s.bgActive = s.bgActive || "bg_default";
    s.muted = typeof s.muted === 'boolean' ? s.muted : false;
    return s;
  }catch(e){
    return { coins:0, best:0, owned:["skin_basic"], active:"skin_basic", bgActive:"bg_default", muted:false };
  }
}
function saveState(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
}

/* -----------------------------
   Base state
   ----------------------------- */
let state = loadState();

/* -----------------------------
   Canvas & Dimensions
   ----------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

function fitCanvas(){
  // keep landscape-friendly aspect and fill parent area
  const parentRect = canvas.parentElement.getBoundingClientRect();
  let w = Math.min(parentRect.width, 1400);
  let h = Math.min(parentRect.height, 820);
  // enforce 16:9-ish logical ratio
  const targetRatio = 16/9;
  if(w / h > targetRatio) { w = Math.round(h * targetRatio); }
  else { h = Math.round(w / targetRatio); }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* -----------------------------
   Game world variables
   ----------------------------- */
let W = () => canvas.width / DPR;
let H = () => canvas.height / DPR;

let gameState = 'menu'; // menu, playing, paused, gameover
let score = 0;
let distance = 0;
let speed = 3.4;
let gravity = 0.45;
let jumpVelocity = -8.4;
let lastTimestamp = 0;

/* -----------------------------
   Player (cube) entity
   ----------------------------- */
let player = {
  x: 180,
  y: H()/2,
  vy: 0,
  w: 46,
  h: 46,
  rotation: 0,
  alive: true,
  mode: 'cube', // 'cube' basic, 'ship' flight, 'ball' bounce, etc.
  modeTimer: 0
};

/* -----------------------------
   Procedural obstacles & portals
   Each segment is an object with type and geometry
   Types: 'spike', 'block', 'moving', 'gap', 'portal'
   ----------------------------- */
let segments = []; // queue of upcoming obstacles
let spawnTimer = 0;
let spawnInterval = 900; // ms

/* Coins (placed in special segments) */
let coinItems = [];

/* Particles for polish */
let particles = [];

/* Background layers for parallax */
const bgLayers = [
  { speed: 0.12, colorTop:'#cbeeff', colorBottom:'#89d3ff', clouds:8 },
  { speed: 0.3, color:'#7bd1ff' },
  { speed: 0.6, color:'#5bb0e0' }
];

/* -----------------------------
   Skins definitions (explicit; not compressed)
   - We include a handful explicitly and programmatically add more
   - Each skin: id, name, shape, palette, price, purchased
   ----------------------------- */
let skins = [];

/* helper to create skin objects */
function makeSkin(id, name, shape, bodyColor, accentColor, price, purchased=false){
  return { id, name, shape, bodyColor, accentColor, price, purchased };
}

// explicit basic skins
skins.push(makeSkin('skin_basic','Basic Cube','cube','#FFD54F','#FFA000', 0, state.owned.includes('skin_basic')));
skins.push(makeSkin('skin_round','Round','rounded','#4DD0E1','#00ACC1', 20, state.owned.includes('skin_round')));
skins.push(makeSkin('skin_ship','Ship','ship','#FF8A65','#FF7043', 40, state.owned.includes('skin_ship')));
skins.push(makeSkin('skin_neon','Neon','neon','#8E24AA','#D81B60', 60, state.owned.includes('skin_neon')));
skins.push(makeSkin('skin_wood','Wood','wood','#A1887F','#6D4C41', 30, state.owned.includes('skin_wood')));

// programmatically add more skins to reach many items (but explicit fields)
for(let i=5;i<40;i++){
  const hue = (i*23) % 360;
  const body = `hsl(${hue} 70% 55%)`;
  const acc = `hsl(${(hue+40)%360} 80% 60%)`;
  const id = 'skin_gen_'+i;
  const name = 'Skin ' + (i+1);
  const shape = (i%4===0)?'ship':((i%4===1)?'rounded':((i%4===2)?'cube':'neon'));
  const price = 10 + i*5;
  skins.push(makeSkin(id, name, shape, body, acc, price, state.owned.includes(id)));
}

// ensure state.active exists and matches purchased rule
if(!state.owned.includes('skin_basic')) state.owned.push('skin_basic');
if(!state.active || !skins.find(s=>s.id===state.active)) state.active = 'skin_basic';
skins.forEach(s=>{ s.purchased = state.owned.includes(s.id); });

/* Background skins */
const bgSkins = [
  { id:'bg_default', name:'Default Sky', colors:['#87d3ff','#bfe9ff'], price:0, purchased:true },
  { id:'bg_dusk', name:'Dusk', colors:['#2c3e50','#fd746c'], price:50, purchased: state.owned.includes('bg_dusk') },
  { id:'bg_neon', name:'Neon Glow', colors:['#0f172a','#6ee7b7'], price:80, purchased: state.owned.includes('bg_neon') }
];

// coin visuals (simple)
const coinSkins = [
  { id:'coin_gold', name:'Gold Coin', color:'#f6c84c', shine:'#fff1a8' },
  { id:'coin_blue', name:'Blue Coin', color:'#60a5fa', shine:'#a3d8ff' }
];

/* -----------------------------
   Audio: WebAudio for music + sfx
   We'll build a lightweight loop using oscillators and noise
   ----------------------------- */
let audioCtx = null;
let masterGain = null;
let musicNodes = [];
let sfxGain = null;

function initAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = state.muted ? 0 : 0.9;
    masterGain.connect(audioCtx.destination);
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.9;
    sfxGain.connect(masterGain);
    buildMusicLoop();
  }catch(e){
    console.warn('Audio nicht verf√ºgbar', e);
  }
}
function buildMusicLoop(){
  if(!audioCtx) return;
  // simple ambient arpeggio using 3 oscillators and a periodic envelope
  const cGain = audioCtx.createGain(); cGain.gain.value = 0.06; cGain.connect(masterGain);
  const osc1 = audioCtx.createOscillator(); osc1.type='sine'; osc1.frequency.value=110; osc1.connect(cGain); osc1.start();
  const osc2 = audioCtx.createOscillator(); osc2.type='sine'; osc2.frequency.value=220; osc2.connect(cGain); osc2.start();
  const osc3 = audioCtx.createOscillator(); osc3.type='sine'; osc3.frequency.value=330; osc3.connect(cGain); osc3.start();
  musicNodes = [osc1,osc2,osc3,cGain];
  // gentle periodic volume modulation
  const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.1;
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.04;
  lfo.connect(lfoGain); lfoGain.connect(cGain.gain);
  lfo.start();
}
function toggleMute(){
  state.muted = !state.muted;
  if(masterGain) masterGain.gain.value = state.muted?0:0.9;
  document.getElementById('btnMute').textContent = state.muted? 'üîà':'üîä';
  saveState();
}
function playSfx(freq=700, time=0.06, type='sine', vol=0.12){
  if(!audioCtx || state.muted) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(sfxGain || masterGain);
  o.start();
  o.stop(audioCtx.currentTime + time);
}

/* -----------------------------
   Utility helpers
   ----------------------------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return !(ax+aw < bx || bx+bw < ax || ay+ah < by || by+bh < ay);
}

/* -----------------------------
   Spawn procedural segments
   We keep things explicit and step-by-step
   ----------------------------- */
function createSpikeSegment(x, top){
  return { type:'spike', x:x, top:top, w:64 };
}
function createBlockSegment(x, top, h){
  return { type:'block', x:x, top:top, h:h, w:64 };
}
function createMovingBlock(x, top, h, speedY){
  return { type:'moving', x:x, top:top, h:h, w:56, speedY: speedY, dir:1 };
}
function createGapSegment(x, top){
  return { type:'gap', x:x, top:top, w:96 };
}
function createPortal(x, top, portalType){
  return { type:'portal', x:x, top:top, w:64, portalType: portalType }; // portalType: 'ship','flip','boost'
}

function spawnRandomSegment(baseX){
  // choose a random pattern and push appropriate segments
  const r = Math.random();
  if(r < 0.18){
    // narrow gap with spike above/below
    const top = Math.floor(rand(110, H()-pipeGap-120));
    segments.push(createBlockSegment(baseX, 0, top)); // top block
    segments.push(createBlockSegment(baseX, top + 170, H() - (top + 170))); // bottom block
    // coin in center of gap
    coinItems.push({ x: baseX + 32, y: top + 85, r:10, taken:false });
  } else if(r < 0.36){
    // moving block and spike
    const top = Math.floor(rand(120, H()-250));
    segments.push(createMovingBlock(baseX, top, 80, rand(0.6,1.4)));
    coinItems.push({ x: baseX + 32, y: top - 20, r:10, taken:false });
  } else if(r < 0.52){
    // portal (ship)
    const top = Math.floor(rand(140, H()-220));
    segments.push(createPortal(baseX, top, 'ship'));
    // coin near portal
    coinItems.push({ x: baseX + 32, y: top + 32, r:10, taken:false });
  } else if(r < 0.68){
    // boost area: small gap then booster ramp (we represent as block with special flag)
    const top = Math.floor(rand(120, H()-200));
    const b = createBlockSegment(baseX, 0, top);
    b.boost = true;
    segments.push(b);
    segments.push(createBlockSegment(baseX, top + 160, H() - (top + 160)));
    coinItems.push({ x: baseX + 32, y: top + 80, r:10, taken:false });
  } else if(r < 0.84){
    // narrow corridor
    const top = Math.floor(rand(140, H()-200));
    segments.push(createBlockSegment(baseX, 0, top - 40 ));
    segments.push(createBlockSegment(baseX, top + 100, H() - (top + 100)));
    coinItems.push({ x: baseX + 32, y: top + 30, r:10, taken:false });
  } else {
    // wide gap
    const top = Math.floor(rand(80, H()-250));
    segments.push(createBlockSegment(baseX, 0, top));
    segments.push(createBlockSegment(baseX, top + 220, H() - (top + 220)));
    coinItems.push({ x: baseX + 40, y: top + 110, r:10, taken:false });
  }
}

/* -----------------------------
   Level spawn manager - explicit, not compressed
   ----------------------------- */
let lastSpawnX = 0;
function updateSpawning(dt){
  // dt in ms
  spawnTimer += dt;
  // spawn by time AND by distance to keep it consistent across frame drops
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    // compute base x just beyond right side
    const baseX = W() + 60;
    // spawn variety of items explicitly
    spawnRandomSegment(baseX);
    // occasionally spawn portal directly
    if(Math.random() < 0.12){
      const y = Math.floor(rand(140, H()-160));
      segments.push(createPortal(baseX + 160, y, (Math.random()<0.5)?'ship':(Math.random()<0.5?'flip':'boost')));
    }
  }
}

/* -----------------------------
   Update function (physics, entities)
   ----------------------------- */
function update(dt){
  // dt: ms since last frame
  if(gameState === 'playing'){
    // update player
    player.vy += gravity;
    player.y += (player.vy * (dt/16.67)); // scale to ~60fps baseline
    // player rotation for visual
    player.rotation = clamp(player.vy * 0.03, -1.2, 1.6);

    // if in special mode (ship), handle flight
    if(player.mode === 'ship'){
      // in ship mode vertical control is different: gentle upward when input active
      // (we handle input elsewhere - modeTimer decreases)
      // when modeTimer expires, revert to cube
      player.modeTimer -= dt;
      if(player.modeTimer <= 0){
        player.modeTimer = 0;
        player.mode = 'cube';
      }
    }

    // move segments left according to speed
    for(let i = segments.length-1; i >= 0; i--){
      const seg = segments[i];
      seg.x -= speed * (dt / 16.67);
      // dynamic moving blocks: update vertical motion
      if(seg.type === 'moving'){
        seg.top += seg.speedY * seg.dir * (dt / 16.67);
        // clamp oscillation
        if(seg.top < 60 || seg.top > H() - seg.h - 60) seg.dir *= -1;
      }
      // collision checks: approximate by rectangles for blocks/spikes
      if(seg.type === 'block' || seg.type === 'moving'){
        // top block rect: x->x+w, y->0->seg.top
        if(rectsOverlap(player.x - player.w/2, player.y - player.h/2, player.w, player.h, seg.x, 0, seg.w, seg.top)){
          // if boost property -> grant speed burst and coin? but colliding kills
          playerDie();
        }
        // bottom block rect
        const bottomY = seg.top + 160; // gap size encoded as 160 for these generation functions
        if(rectsOverlap(player.x - player.w/2, player.y - player.h/2, player.w, player.h, seg.x, bottomY, seg.w, H() - bottomY)){
          playerDie();
        }
      } else if(seg.type === 'spike'){
        // spikes represented as thin rects
        if(rectsOverlap(player.x - player.w/2, player.y - player.h/2, player.w, player.h, seg.x, seg.top - 24, seg.w, 24)){
          playerDie();
        }
      } else if(seg.type === 'portal'){
        // portal detection
        const px = seg.x, pw = seg.w;
        if(player.x + player.w/2 > px && player.x - player.w/2 < px + pw){
          // trigger portal effect
          if(!seg.triggered){
            seg.triggered = true;
            if(seg.portalType === 'ship'){
              player.mode = 'ship';
              player.modeTimer = 2600; // ms
              playSfx(1200, 0.14, 'sine', 0.12);
            } else if(seg.portalType === 'flip'){
              gravity *= -1;
              setTimeout(()=>{ gravity *= -1; }, 1800);
              playSfx(520, 0.16, 'triangle', 0.11);
            } else if(seg.portalType === 'boost'){
              speed += 1.4;
              setTimeout(()=>{ speed = Math.max(3.4, speed - 1.4); }, 1800);
              playSfx(980, 0.12, 'sawtooth', 0.12);
            }
          }
        }
      }

      // remove offscreen
      if(seg.x + (seg.w || 80) < -200){
        segments.splice(i,1);
      }
    }

    // move coins and check collection
    for(let i = coinItems.length - 1; i >= 0; i--){
      const c = coinItems[i];
      c.x -= speed * (dt / 16.67);
      // simple float animation
      // collision with player
      if(!c.taken && dist(c.x, c.y, player.x, player.y) < c.r + Math.max(player.w, player.h)/2 - 6){
        c.taken = true;
        state.coins = (state.coins || 0) + 1;
        playSfx(1200, 0.08, 'sine', 0.11);
        // spawn small particles
        for(let p=0;p<8;p++){ particles.push({ x:c.x, y:c.y, vx:rand(-1.2,1.2), vy:rand(-3,-1), life:40 + Math.random()*20 }); }
        // remove coin
        coinItems.splice(i,1);
      } else if(c.x < -80){
        coinItems.splice(i,1);
      }
    }

    // particles update
    for(let i = particles.length-1; i>=0; i--){
      const p = particles[i];
      p.x += p.vx * (dt / 16.67);
      p.y += p.vy * (dt / 16.67);
      p.vy += 0.12;
      p.life -= (dt/16.67) * 1;
      if(p.life <= 0) particles.splice(i,1);
    }

    // distance & score
    distance += speed * (dt / 16.67);
    score = Math.floor(distance);

    // spawn manager
    updateSpawning(dt);

    // failure if out of bounds (below ground or above ceiling)
    if(player.y - player.h/2 > H() - 20 || player.y + player.h/2 < -20){
      playerDie();
    }
  } // if playing
}

/* -----------------------------
   Drawing the world (render)
   explicit long-form drawing for polish
   ----------------------------- */
function render(){
  // clear
  ctx.clearRect(0,0,W(),H());

  // choose background from state.bgActive
  let bg = bgSkins.find(b=>b.id===state.bgActive) || bgSkins[0];

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,H());
  g.addColorStop(0, bg.colors ? bg.colors[0] : '#87d3ff');
  g.addColorStop(1, bg.colors ? bg.colors[1] : '#bfe9ff');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W(),H());

  // parallax layers (explicit)
  drawParallax();

  // ground
  ctx.fillStyle = '#134e4a';
  ctx.fillRect(0, H()-60, W(), 60);
  ctx.fillStyle = '#0a3a36';
  for(let i=0;i<Math.ceil(W()/24)+4;i++){
    const x = (i*24 - (Math.floor(distance)%24));
    ctx.fillRect(x, H()-28, 12, 8);
  }

  // draw segments (blocks, portals, spikes)
  for(const seg of segments){
    if(seg.type === 'block' || seg.type === 'moving'){
      // top
      ctx.fillStyle = '#1e7a5a';
      ctx.fillRect(seg.x, 0, seg.w, seg.top);
      // top cap
      ctx.fillStyle = '#166b4b';
      ctx.fillRect(seg.x-6, seg.top-16, seg.w+12, 16);
      // bottom
      const bottomY = seg.top + 160;
      ctx.fillStyle = '#1e7a5a';
      ctx.fillRect(seg.x, bottomY, seg.w, H() - bottomY - 60);
      // bottom cap
      ctx.fillStyle = '#166b4b';
      ctx.fillRect(seg.x-6, bottomY, seg.w+12, 16);

      // if moving show highlight
      if(seg.type === 'moving'){
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.strokeRect(seg.x+2, seg.top+2, seg.w-4, seg.h-4);
      }

      // boost visual
      if(seg.boost){
        ctx.fillStyle = 'rgba(255,200,100,0.12)';
        ctx.fillRect(seg.x, seg.top + 60, seg.w, 40);
      }
    } else if(seg.type === 'portal'){
      // portal ring
      const ringX = seg.x + seg.w/2;
      const ringY = seg.top + 32;
      ctx.save();
      // outer ring
      ctx.beginPath();
      ctx.arc(ringX, ringY, 28, 0, Math.PI*2);
      ctx.fillStyle = seg.portalType === 'ship' ? '#ffd54f' : seg.portalType === 'flip' ? '#8e24aa' : '#60a5fa';
      ctx.fill();
      // inner hole
      ctx.beginPath();
      ctx.arc(ringX, ringY, 14, 0, Math.PI*2);
      ctx.fillStyle = '#083344';
      ctx.fill();
      ctx.restore();
      // little sparkles
      for(let s=0;s<4;s++){
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.fillRect(seg.x + s*6, seg.top + 6 + (Math.sin((Date.now()+s*120)/120)*4), 2,2);
      }
    } else if(seg.type === 'spike'){
      // draw spikes at seg.top (thin)
      ctx.fillStyle = '#c62828';
      ctx.fillRect(seg.x, seg.top-20, seg.w, 20);
    }
  }

  // draw coins
  for(const c of coinItems){
    ctx.save();
    ctx.translate(c.x, c.y);
    const rot = Math.sin(Date.now()*0.003 + c.x*0.002) * 0.4;
    ctx.rotate(rot);
    ctx.fillStyle = '#f6c84c';
    ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff1a8';
    ctx.beginPath(); ctx.arc(-c.r*0.25, -c.r*0.25, c.r*0.45, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // draw player (explicit, not just a rectangle). Use skin to vary shape
  const skin = skins.find(s => s.id === state.active) || skins[0];
  drawPlayerSprite(player, skin);

  // particles
  for(const p of particles){
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, p.life/60)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(1, p.life*0.03), 0, Math.PI*2); ctx.fill();
  }

  // center UI (score big)
  ctx.font = 'bold 44px Inter, system-ui, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.textAlign = 'center';
  ctx.fillText(score, W()/2 + 4, 74 + 4);
  ctx.fillStyle = '#fff';
  ctx.fillText(score, W()/2, 74);

  // update HUD DOM
  document.getElementById('hudCoins').textContent = state.coins;
  document.getElementById('hudHigh').textContent = state.best || 0;
  document.getElementById('hudScore').textContent = score;
}

/* draw player sprite (explicit multi-shape) */
function drawPlayerSprite(p, skin){
  // p.x, p.y, p.w, p.h
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rotation);
  const size = Math.max(18, p.w * 0.9);
  if(skin.shape === 'cube'){
    // cube with outline
    ctx.fillStyle = skin.bodyColor;
    ctx.fillRect(-size/2, -size/2, size, size);
    ctx.strokeStyle = skin.accentColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(-size/2, -size/2, size, size);
  } else if(skin.shape === 'rounded' || skin.shape === 'rounded' || skin.shape === 'rounded'){
    ctx.fillStyle = skin.bodyColor;
    roundRect(ctx, -size/2, -size/2, size, size, 10);
    ctx.fill();
    ctx.strokeStyle = skin.accentColor;
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if(skin.shape === 'ship'){
    // little ship nose + body
    ctx.fillStyle = skin.bodyColor;
    ctx.beginPath();
    ctx.moveTo(-size*0.6, size*0.2);
    ctx.lineTo(size*0.6, 0);
    ctx.lineTo(-size*0.6, -size*0.2);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = skin.accentColor;
    ctx.fillRect(-size*0.6, -size*0.25, size*0.18, size*0.5);
  } else if(skin.shape === 'neon'){
    ctx.fillStyle = skin.bodyColor;
    ctx.fillRect(-size/2, -size/2, size, size);
    // neon glow
    ctx.fillStyle = skin.accentColor + '33';
    ctx.fillRect(-size/2 - 6, -size/2 - 6, size+12, size+12);
  } else if(skin.shape === 'rounded'){ // fallback
    ctx.fillStyle = skin.bodyColor; roundRect(ctx, -size/2,-size/2,size,size,8); ctx.fill();
  } else {
    // default cube
    ctx.fillStyle = skin.bodyColor;
    ctx.fillRect(-size/2, -size/2, size, size);
  }
  // eye or cockpit indicator
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(size*0.18, -size*0.12, Math.max(2, size*0.08), 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.arc(size*0.22, -size*0.12, Math.max(1.1, size*0.04), 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

/* small helper: rounded rect drawing */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* simple distance */
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }

/* draw parallax background explicit */
function drawParallax(){
  // sky clouds layer
  const t = Date.now();
  ctx.save();
  for(let i=0;i<6;i++){
    const cx = ((t*0.02) + i*220) % (W()+400) - 200;
    const cy = 80 + (i%2)*30;
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.ellipse(cx, cy, 68, 26, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx+36, cy+10, 42, 18, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

/* -----------------------------
   Player death & restart
   ----------------------------- */
function playerDie(){
  if(!player.alive) return;
  player.alive = false;
  playSfx(160, 0.2, 'sawtooth', 0.14);
  gameState = 'gameover';
  // show overlay after short delay
  setTimeout(()=> {
    document.getElementById('overlayGameOver').style.display = 'grid';
    document.getElementById('goScore').textContent = score;
    document.getElementById('goBest').textContent = Math.max(state.best || 0, score);
  }, 350);
  // save best and coins
  if(!state.best || score > state.best) state.best = score;
  saveState();
}

/* restart cleaned explicit */
function restartGame(){
  // hide overlays
  document.getElementById('overlayGameOver').style.display = 'none';
  // reset variables extensively
  player.x = 180;
  player.y = H()/2;
  player.vy = 0;
  player.rotation = 0;
  player.alive = true;
  player.mode = 'cube';
  player.modeTimer = 0;
  segments = [];
  coinItems = [];
  particles = [];
  spawnTimer = 0;
  spawnInterval = 900;
  distance = 0;
  score = 0;
  speed = 3.4;
  gravity = Math.abs(gravity); // reset
  gameState = 'playing';
}

/* -----------------------------
   Input handling (explicit)
   ----------------------------- */
let inputActive = false;
function onJumpStart(){
  // if menu show start
  if(gameState === 'menu' || gameState === 'paused'){
    // start game
    startPlaying();
    return;
  }
  if(gameState === 'gameover'){
    restartGame();
    return;
  }
  // normal jump/ship control
  if(player.mode === 'ship'){
    // small upward impulse instead of jump
    player.vy = -3.6;
  } else {
    // regular jump
    player.vy = jumpVelocity;
  }
  playSfx(900 + Math.random()*160, 0.06, 'sine', 0.12);
  inputActive = true;
}
function onJumpEnd(){
  inputActive = false;
}

function startPlaying(){
  initAudio();
  if(!audioCtx) { /* audio not init */ }
  // hide menu
  document.getElementById('overlayMenu').style.display = 'none';
  gameState = 'playing';
  player.x = 180;
  player.y = H()/2;
  player.vy = 0;
  distance = 0;
  score = 0;
  segments = []; coinItems = []; particles = [];
  spawnTimer = 0; spawnInterval = 900;
  // small initial spawn
  for(let i=0;i<3;i++) spawnRandomSegment(W() + i*420);
}

/* keyboard & pointer events */
document.addEventListener('keydown', (e)=>{
  if(e.repeat) return;
  if(e.code === 'Space' || e.code === 'ArrowUp'){
    e.preventDefault();
    onJumpStart();
  } else if(e.code === 'KeyS'){
    toggleShop();
  } else if(e.code === 'KeyP'){
    if(gameState === 'playing') { gameState = 'paused'; document.getElementById('overlayMenu').style.display = 'grid'; }
    else if(gameState === 'paused') { document.getElementById('overlayMenu').style.display = 'none'; gameState = 'playing'; }
  } else if(e.code === 'KeyM'){
    toggleMute();
  } else if(e.code === 'KeyR'){
    restartGame();
  } else if(e.code === 'Escape'){
    // close overlays
    document.getElementById('overlayMenu').style.display = 'none';
    document.getElementById('overlayShop').style.display = 'none';
    document.getElementById('overlayHelp').style.display = 'none';
    gameState = gameState === 'menu' ? 'menu' : gameState;
  }
});
document.addEventListener('keyup', (e)=>{
  if(e.code === 'Space' || e.code === 'ArrowUp') onJumpEnd();
});
canvas.addEventListener('pointerdown', (e)=>{ onJumpStart(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
canvas.addEventListener('pointerup', ()=> onJumpEnd());
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); onJumpStart(); }, {passive:false});
canvas.addEventListener('touchend', ()=> onJumpEnd());

/* -----------------------------
   Spawn helper uses explicit generation to create clear long code
   ----------------------------- */
function spawnIfNeeded(dt){
  // create segments to ensure a continuous runway. We check rightmost segment.x
  // and spawn when there is space.
  if(segments.length === 0){
    spawnRandomSegment(W() + 120);
  } else {
    const rightmost = segments[segments.length - 1];
    if(rightmost.x < W() - 300){
      spawnRandomSegment(W() + 120);
    }
  }
}

/* -----------------------------
   main loop (explicit handling)
   ----------------------------- */
let requestedAnim = null;
function mainLoop(timestamp){
  if(!lastTimestamp) lastTimestamp = timestamp;
  const dt = timestamp - lastTimestamp;
  lastTimestamp = timestamp;

  if(gameState === 'playing'){
    update(dt);
  } else if(gameState === 'menu'){
    // idle animations (floating)
    player.y = H()/2 + Math.sin(timestamp*0.002) * 8;
  } else if(gameState === 'paused'){
    // no updates
  } else if(gameState === 'gameover'){
    // falling animation
    player.vy += gravity * (dt/16.67);
    player.y += player.vy * (dt/16.67);
  }

  render();

  requestedAnim = requestAnimationFrame(mainLoop);
}
requestedAnim = requestAnimationFrame(mainLoop);

/* -----------------------------
   Shop UI build (explicit & scrollable)
   ----------------------------- */
function buildShopUI(){
  const grid = document.getElementById('skinGrid');
  grid.innerHTML = '';
  for(const skin of skins){
    const card = document.createElement('div'); card.className = 'skin-card';
    const preview = document.createElement('div'); preview.className = 'preview';
    // draw preview canvas
    const pv = document.createElement('canvas'); pv.width = 240; pv.height = 140;
    pv.style.width = '100%'; pv.style.height = '100%';
    const pctx = pv.getContext('2d');
    // background stripe
    pctx.fillStyle = '#0b1220';
    pctx.fillRect(0,0,240,140);
    // draw shape
    pctx.fillStyle = skin.bodyColor;
    if(skin.shape === 'cube'){
      pctx.fillRect(80,28,80,80);
    } else if(skin.shape === 'rounded'){
      pctx.fillStyle = skin.bodyColor;
      pctx.beginPath(); pctx.ellipse(120,68,40,36,0,0,2*Math.PI); pctx.fill();
    } else if(skin.shape === 'ship'){
      pctx.beginPath(); pctx.moveTo(60,70); pctx.lineTo(180,50); pctx.lineTo(60,90); pctx.closePath(); pctx.fill();
    } else { pctx.fillRect(80,28,80,80); }
    preview.appendChild(pv);
    card.appendChild(preview);
    const label = document.createElement('div'); label.className = 'muted'; label.textContent = skin.name; card.appendChild(label);
    const controls = document.createElement('div'); controls.style.display='flex'; controls.style.gap='8px';
    const btn = document.createElement('button');
    if(state.owned.includes(skin.id)){
      btn.textContent = (state.active === skin.id) ? 'Aktiv' : 'W√§hlen';
      btn.className = 'ghost';
      btn.disabled = state.active === skin.id;
      btn.addEventListener('click', ()=>{ if(state.owned.includes(skin.id)){ state.active = skin.id; saveState(); buildShopUI(); } });
    } else {
      btn.textContent = `Kaufen ${skin.price}ü™ô`;
      btn.className = 'cta';
      btn.addEventListener('click', ()=>{
        if(state.coins >= skin.price){
          state.coins -= skin.price;
          state.owned.push(skin.id);
          saveState();
          buildShopUI();
          playSfx(900, 0.08, 'triangle', 0.12);
        } else {
          // feedback
          document.getElementById('hudCoins').animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}], { duration: 360 });
          playSfx(240,0.06,'square',0.08);
        }
      });
    }
    controls.appendChild(btn);
    card.appendChild(controls);
    grid.appendChild(card);
  }

  // background options
  const bgGrid = document.getElementById('bgGrid'); bgGrid.innerHTML = '';
  for(const bg of bgSkins){
    const card = document.createElement('div'); card.className = 'skin-card';
    const preview = document.createElement('div'); preview.className = 'preview';
    const pv = document.createElement('canvas'); pv.width = 240; pv.height = 140;
    pv.style.width='100%'; pv.style.height='100%';
    const pctx = pv.getContext('2d');
    // draw gradient preview
    const gg = pctx.createLinearGradient(0,0,0,140);
    gg.addColorStop(0, bg.colors[0]); gg.addColorStop(1, bg.colors[1]);
    pctx.fillStyle = gg; pctx.fillRect(0,0,240,140);
    preview.appendChild(pv);
    card.appendChild(preview);
    const label = document.createElement('div'); label.className='muted'; label.textContent = bg.name; card.appendChild(label);
    const btn = document.createElement('button');
    if(state.bgActive === bg.id){
      btn.textContent = 'Aktiv';
      btn.className = 'ghost';
      btn.disabled = true;
    } else if(state.owned.includes(bg.id)){
      btn.textContent = 'W√§hlen'; btn.className='ghost';
      btn.addEventListener('click', ()=>{ state.bgActive = bg.id; saveState(); buildShopUI(); });
    } else {
      btn.textContent = `Kaufen ${bg.price}ü™ô`; btn.className='cta';
      btn.addEventListener('click', ()=>{
        if(state.coins >= bg.price){ state.coins -= bg.price; state.owned.push(bg.id); state.bgActive = bg.id; saveState(); buildShopUI(); }
        else { playSfx(260,0.06,'square',0.07); }
      });
    }
    card.appendChild(btn);
    bgGrid.appendChild(card);
  }

  // update shop coins
  document.getElementById('shopCoins').textContent = state.coins || 0;
}

/* -----------------------------
   Small helpers for spawn
   ----------------------------- */
function spawnRandomSegment(xBase){
  // create variety intentionally by separate blocks
  const choice = Math.random();
  if(choice < 0.12){ // single moving block
    const top = Math.floor(rand(100, H() - 240));
    segments.push(createBlockSegment(xBase, top, 80));
  } else if(choice < 0.28){
    // block pair with coin in gap
    const top = Math.floor(rand(120, H() - 260));
    const topBlock = { type:'block', x:xBase, top: top, w:80 };
    const bottomBlock = { type:'block', x:xBase, top: top + 160, w:80 };
    segments.push(topBlock); segments.push(bottomBlock);
    coinItems.push({ x: xBase + 40, y: top + 80, r: 10, taken:false });
  } else if(choice < 0.42){
    // portal
    const top = Math.floor(rand(120, H() - 200));
    const portalType = (Math.random()<0.5)?'ship':(Math.random()<0.5?'flip':'boost');
    segments.push(createPortal(xBase, top, portalType));
  } else if(choice < 0.62){
    // spike row
    const top = Math.floor(rand(140, H() - 200));
    segments.push(createSpikeSegment(xBase, top));
  } else {
    // wide gap
    const top = Math.floor(rand(80, H() - 260));
    segments.push({ type:'block', x:xBase, top:top, w:90 });
    segments.push({ type:'block', x:xBase, top:top + 220, w:90 });
    coinItems.push({ x: xBase + 44, y: top + 110, r: 10, taken:false });
  }
}

/* small constructors used above (explicit duplicates kept to preserve verbosity) */
function createBlockSegment(x, top, h){
  return { type:'block', x:x, top:top, h:h, w:80 };
}
function createPortal(x, top, portalType){
  return { type:'portal', x:x, top:top, w:64, portalType: portalType, triggered:false };
}
function createSpikeSegment(x, top){
  return { type:'spike', x:x, top:top, w:80 };
}

/* -----------------------------
   UI bindings & control wiring
   ----------------------------- */
document.getElementById('startButton').addEventListener('click', ()=>{ startPlaying(); });
document.getElementById('openShopButton').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display = 'grid'; buildShopUI(); });
document.getElementById('shopClose').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display='none'; });
document.getElementById('shopCloseBtn').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display='none'; });
document.getElementById('btnShop').addEventListener('click', ()=>{ const el=document.getElementById('overlayShop'); el.style.display = (el.style.display === 'grid') ? 'none' : 'grid'; buildShopUI(); });
document.getElementById('btnMute').addEventListener('click', toggleMute);
document.getElementById('btnPause').addEventListener('click', ()=>{ if(gameState==='playing'){ gameState='paused'; document.getElementById('overlayMenu').style.display='grid'; } else { gameState='playing'; document.getElementById('overlayMenu').style.display='none'; }});
document.getElementById('btnHelp').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='grid'; });
document.getElementById('helpClose').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('helpOk').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('btnRestart').addEventListener('click', ()=>{ restartGame(); });

// close menu overlay by click X
document.getElementById('closeIntroBtn').addEventListener('click', ()=>{ document.getElementById('overlayMenu').style.display='none'; startPlaying(); });

/* -----------------------------
   Init audio on first user gesture (some browsers block it otherwise)
   ----------------------------- */
function initAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);
    masterGain.gain.value = state.muted ? 0 : 0.9;
    sfxGain = audioCtx.createGain(); sfxGain.connect(masterGain); sfxGain.gain.value = 1.0;
    buildMusicLoop();
  }catch(e){
    console.warn('Audio init failed', e);
  }
}

/* -----------------------------
   Save on unload
   ----------------------------- */
window.addEventListener('beforeunload', ()=>{ saveState(); });

/* -----------------------------
   Start playing helper
   ----------------------------- */
function startPlaying(){
  initAudio();
  if(!audioCtx){} // ignore if audio blocked
  document.getElementById('overlayMenu').style.display = 'none';
  document.getElementById('overlayShop').style.display = 'none';
  document.getElementById('overlayGameOver').style.display = 'none';
  gameState = 'playing';
  // reset some values explicitly
  player.x = 180; player.y = H()/2; player.vy = 0; player.alive = true; player.mode = 'cube'; player.modeTimer = 0;
  segments = []; coinItems = []; particles = []; spawnTimer = 0; distance = 0; score = 0;
  // pre-spawn a few segments
  for(let i=0;i<4;i++){ spawnRandomSegment(W() + i*420); }
}

/* -----------------------------
   small helper sfx wrapper
   ----------------------------- */
function playSfx(freq, dur, type, vol){
  if(!audioCtx || state.muted) return;
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type || 'sine';
    o.frequency.value = freq || 600;
    g.gain.value = vol || 0.08;
    o.connect(g); g.connect(masterGain);
    o.start();
    o.stop(audioCtx.currentTime + (dur || 0.08));
  }catch(e){}
}

/* -----------------------------
   Kick off initial UI values
   ----------------------------- */
document.getElementById('hudCoins').textContent = state.coins || 0;
document.getElementById('hudHigh').textContent = state.best || 0;
document.getElementById('hudScore').textContent = 0;
document.getElementById('shopCoins').textContent = state.coins || 0;

/* -----------------------------
   Done: You can now play CubeLand.
   Additions and tweaks:
   - To add skins: append to `skins` array with explicit properties.
   - To add backgrounds: append to `bgSkins` similarly.
   - The shop UI and purchase logic is explicit above.
   ----------------------------- */
</script>
</body>
</html>
