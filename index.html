<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bernau Games - CubeLand v2.7</title>
<style>
:root{
  --bg-top:#03040a; --bg-bottom:#071226;
  --tile:#081a24; --tileEdge:#0f3350;
  --neon1:#06b6d4; --neon2:#7c3aed; --neon3:#f472b6; --neon4:#22c55e;
  --gold:#f6c84c;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff}
#wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:12px}
canvas#game{
  width:100%; height:100%; max-width:1400px; max-height:860px;
  border-radius:12px; background:#071226; border:1px solid rgba(255,255,255,.04);
  box-shadow:0 40px 140px rgba(0,0,0,.75); display:block; position:relative; z-index:1;
}
.hud{position:absolute;left:16px;top:12px;display:flex;gap:8px;z-index:60;pointer-events:none}
.pill{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.05);border-radius:999px;padding:8px 12px;font-weight:800}
.right{position:absolute;right:16px;top:12px;display:flex;gap:8px;z-index:60}
.icon{width:42px;height:36px;display:grid;place-items:center;border-radius:10px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);cursor:pointer;user-select:none;z-index:70}
.icon:active{transform:scale(.98)}
/* overlays above canvas */
.overlay{position:absolute;inset:0;display:none;place-items:center;background:rgba(2,3,6,0.78);z-index:999;pointer-events:auto}
.overlay.show{display:grid}
.card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:16px;max-width:980px;width:min(94vw,980px);box-shadow:0 30px 90px rgba(0,0,0,.6)}
.row{display:flex;gap:10px;align-items:center;justify-content:space-between}
.cta{background:linear-gradient(90deg,var(--neon2),var(--neon1));border:none;border-radius:10px;padding:10px 14px;color:#fff;font-weight:900;cursor:pointer}
.ghost{background:transparent;border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px 12px;color:#fff;cursor:pointer}
.small{font-size:12px;opacity:.85}
.close{position:absolute;right:10px;top:10px;border-radius:999px;background:rgba(255,255,255,.06);padding:6px 8px;cursor:pointer}
.shop-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;max-height:52vh;overflow:auto;margin-top:8px}
.skin-card{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:8px}
.preview{height:96px;border-radius:8px;overflow:hidden;background:linear-gradient(180deg,#07121f,#050b15);display:flex;align-items:center;justify-content:center}
@media (max-width:640px){ canvas#game{border-radius:8px} .card{padding:12px} }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="1280" height="720" aria-label="Bernau Games - CubeLand"></canvas>

  <div class="hud" aria-hidden="true">
    <div class="pill">üéÆ Bernau Games - CubeLand</div>
    <div class="pill">Score: <b id="hudScore">0</b></div>
    <div class="pill">Best: <b id="hudBest">0</b></div>
    <div class="pill">Coins: <b id="hudCoins">0</b></div>
  </div>

  <div class="right" aria-hidden="false">
    <div class="icon" id="btnPause" title="Pause (P)">‚è∏</div>
    <div class="icon" id="btnMute" title="Mute (M)">üîä</div>
    <div class="icon" id="btnShop" title="Shop (S)">üõçÔ∏è</div>
    <div class="icon" id="btnHelp" title="Hilfe (H)">‚ùì</div>
  </div>

  <!-- Start Menu -->
  <div id="olMenu" class="overlay show" role="dialog" aria-modal="true">
    <div class="card">
      <div class="row">
        <h2 style="margin:0">Bernau Games ‚Äî CubeLand (v2.7)</h2>
        <div class="small">Endlos ¬∑ Zuf√§llige Portale ¬∑ Neon-Blocks</div>
      </div>
      <p style="margin-top:8px">Springe auf quadratische Bl√∂cke, sammle M√ºnzen, durchquere Portale (Ship/Flip). Shop mit Canvas-Skins. Steuerung: Space/Tap springen ¬∑ S Shop ¬∑ P Pause ¬∑ M Mute ¬∑ R Neustart.</p>
      <div class="row" style="margin-top:12px">
        <div>
          <button class="cta" id="btnPlay">‚ñ∂Ô∏è Spielen</button>
          <button class="ghost" id="btnOpenShop">üõçÔ∏è Shop</button>
        </div>
        <div class="small">Empfohlen: Vollbild im Querformat f√ºr beste Erfahrung.</div>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="olGO" class="overlay" role="dialog" aria-modal="true" style="display:none">
    <div class="card">
      <h2 style="margin:0">Game Over</h2>
      <p class="small">Score: <b id="goScore">0</b> ¬∑ Best: <b id="goBest">0</b></p>
      <div class="row" style="margin-top:10px">
        <button class="cta" id="btnRestart">‚Ü∫ Neustarten (R)</button>
        <button class="ghost" id="btnGoShop">üõçÔ∏è Shop</button>
      </div>
    </div>
  </div>

  <!-- Shop -->
  <div id="olShop" class="overlay" role="dialog" aria-modal="true" style="display:none">
    <div class="card" style="position:relative">
      <div class="close" id="shopClose" role="button" aria-label="Schlie√üen">‚úï</div>
      <h3 style="margin:0 0 6px 0">Shop ‚Äî Skins</h3>
      <p class="small">Kaufe Skins mit M√ºnzen. Skins sind Canvas-gezeichnet (keine externen Dateien).</p>
      <div id="skinGrid" class="shop-grid"></div>
      <div class="row" style="margin-top:10px">
        <div>Deine Coins: <b id="shopCoins">0</b></div>
        <button class="ghost" id="btnCloseShop">Schlie√üen</button>
      </div>
    </div>
  </div>

  <!-- Help -->
  <div id="olHelp" class="overlay" role="dialog" aria-modal="true" style="display:none">
    <div class="card" style="position:relative;max-width:560px">
      <div class="close" id="helpClose" role="button" aria-label="Schlie√üen">‚úï</div>
      <h3>Hilfe</h3>
      <p class="small">Normal: Sprung (Space/Tap). Ship: halten = steigen. Flip: invertierte Gravitation. Du landest auf Block-Tops; Seitenkollision oder Stachel = Tod.</p>
      <div style="text-align:center;margin-top:8px"><button class="cta" id="helpOk">Verstanden</button></div>
    </div>
  </div>

</div>

<script>
/* =========================================================================
   Bernau Games ‚Äî CubeLand v2.7
   - Fixes requested by user:
     * infinite obstacles (no stop at score 36)
     * shop toggles (S + buttons) fixed
     * neon tiles for floor/ceiling
     * blocks (no pipes); spikes respect gravity orientation
     * portals occasional (not every section), normal sections also appear
     * jumps higher; rotation = 90¬∞ during jump and stays that way on landing
   - Self-contained single-file game (HTML+CSS+JS)
   ========================================================================= */

/* ---------------- Persistence ---------------- */
const LS_KEY = 'bernau_cubeland_v27';
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY) || '{}');
    return {
      coins: s.coins ?? 0,
      best: s.best ?? 0,
      owned: Array.isArray(s.owned) ? s.owned : ['skin_default'],
      active: s.active || 'skin_default',
      muted: !!s.muted
    };
  }catch(e){
    return { coins:0, best:0, owned:['skin_default'], active:'skin_default', muted:false };
  }
}
function saveState(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
}
let state = loadState();

/* ---------------- Canvas & layout ---------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

function fitCanvas(){
  const p = canvas.parentElement.getBoundingClientRect();
  let w = Math.min(p.width, 1400);
  let h = Math.min(p.height, 860);
  const ratio = 16/9;
  if(w/h > ratio) w = Math.round(h * ratio); else h = Math.round(w / ratio);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();
const Wf = ()=>canvas.width / DPR;
const Hf = ()=>canvas.height / DPR;

/* ---------------- Audio (simple ambient + sfx) ---------------- */
let audioCtx = null, master = null;
function initAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain(); master.gain.value = state.muted ? 0 : 0.72; master.connect(audioCtx.destination);
    buildAmbient();
  }catch(e){
    console.warn('Audio init failed', e);
  }
}
function buildAmbient(){
  if(!audioCtx) return;
  const g = audioCtx.createGain(); g.gain.value = 0.05; g.connect(master);
  const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value=110; o.connect(g); o.start();
  const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=0.08;
  const lfg = audioCtx.createGain(); lfg.gain.value=0.03; lfo.connect(lfg); lfg.connect(g.gain); lfo.start();
}
function sfx(freq=900,dur=0.06,type='sine',vol=0.12){
  if(!audioCtx || state.muted) return;
  try{
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(master);
    o.start(); o.stop(audioCtx.currentTime + dur);
  }catch(e){}
}
function toggleMute(){ state.muted = !state.muted; if(master) master.gain.value = state.muted ? 0 : 0.72; document.getElementById('btnMute').textContent = state.muted ? 'üîà' : 'üîä'; saveState(); }

/* ---------------- Game config ---------------- */
const G = {
  tile: 48,
  floorH: 64,
  gravity: 1.05,
  jump: -20.5,       // stronger jump so player can clear patterns
  shipThrust: -0.72,
  speedBase: 5.0,
  speedMax: 12.0,
  spawnBaseMs: 700,
  coinR: 12,
  portalChance: 0.012, // low chance to start a portal section
  normalSectionChance: 0.15 // chance to spawn denser normal section
};

/* ---------------- Modes ---------------- */
const MODE = { NORMAL:'normal', SHIP:'ship', FLIP:'flip' };
let gameMode = MODE.NORMAL;

/* ---------------- Player ---------------- */
let player = {
  x: 180,
  y: 0,
  w: 60,
  h: 60,
  vy: 0,
  onGround: true,
  alive: true,
  rot: 0,
  targetRot: 0 // rotation that the player will keep; when jumping targetRot=¬±90deg
};

/* ---------------- Skins: canvas-drawn thumbnails ---------------- */
const skins = [];
function addSkin(id,name,price,drawFn){ skins.push({id,name,price,draw:drawFn}); }
addSkin('skin_default','Neon Noir',0,(ctx,w,h)=>{
  // cube black with neon cyan stripes
  ctx.fillStyle='#000'; roundRect(ctx,(w-56)/2,(h-56)/2,56,56,8); ctx.fill();
  ctx.strokeStyle='#06b6d4'; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo((w-56)/2+8,(h-56)/2+56/3); ctx.lineTo((w+56)/2-8,(h-56)/2+56/3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo((w-56)/2+8,(h-56)/2+56*2/3); ctx.lineTo((w+56)/2-8,(h-56)/2+56*2/3); ctx.stroke();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc((w+56)/2 - 8, (h-56)/2 + 10, 6,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc((w+56)/2 - 6, (h-56)/2 + 10, 3,0,Math.PI*2); ctx.fill();
});
addSkin('skin_wings','Winged Cube',40,(ctx,w,h)=>{
  ctx.fillStyle='#071026'; roundRect(ctx,(w-56)/2,(h-56)/2,56,56,8); ctx.fill();
  ctx.fillStyle='#7c3aed'; drawWing(ctx,(w-56)/2 - 10,(h-56)/2 + 10,28,12);
  ctx.fillStyle='#06b6d4'; drawWing(ctx,(w+56)/2 - 18,(h-56)/2 + 10,28,12,true);
  ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2; ctx.strokeRect((w-56)/2+6,(h-56)/2+16,44,12);
});
addSkin('skin_orb','Glowing Orb',50,(ctx,w,h)=>{
  ctx.beginPath(); ctx.arc(w/2,h/2,28,0,Math.PI*2); ctx.fillStyle='#05060a'; ctx.fill();
  const g = ctx.createRadialGradient(w/2-6,h/2-6,2,w/2,h/2,28); g.addColorStop(0,'#ffd54f'); g.addColorStop(1,'#f472b6'); ctx.fillStyle=g; ctx.fill();
});
addSkin('skin_ufo','Mini UFO',80,(ctx,w,h)=>{
  ctx.beginPath(); ctx.ellipse(w/2,h/2,30,16,0,0,Math.PI*2); ctx.fillStyle='#061226'; ctx.fill();
  ctx.fillStyle='#7c3aed'; ctx.fillRect(w/2-12,h/2-8,24,8);
  ctx.fillStyle='#06b6d4'; ctx.beginPath(); ctx.arc(w/2,h/2-8,6,0,Math.PI*2); ctx.fill();
});
if(!state.owned.includes('skin_default')) state.owned.push('skin_default');
if(!skins.find(s=>s.id===state.active)) state.active='skin_default';

/* helper drawing funcs for skin previews */
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function drawWing(ctx,x,y,w,h,flip=false){ ctx.beginPath(); if(!flip){ ctx.moveTo(x,y); ctx.lineTo(x+w,y+h/2); ctx.lineTo(x,y+h); } else { ctx.moveTo(x+w,y); ctx.lineTo(x,y+h/2); ctx.lineTo(x+w,y+h); } ctx.closePath(); ctx.fill(); }
function renderSkinThumb(drawFn,cw=220,ch=88){ const c = document.createElement('canvas'); c.width=cw; c.height=ch; const cc = c.getContext('2d'); cc.fillStyle='#071226'; cc.fillRect(0,0,cw,ch); drawFn(cc,cw,ch); return c; }

/* ---------------- World state ---------------- */
let lastTime = 0;
let obstacles = []; // block / spike / portal objects
let coins = [];
let particles = [];
let spawnAccumulator = 0;
let score = 0;
let best = state.best || 0;
let speed = G.speedBase;
let inSection = false;
let sectionEndX = 0;
let gameState = 'menu'; // 'menu' | 'playing' | 'gameover'
let inputPressed = false;

/* ---------------- Object factories ---------------- */
function makeBlock(x,y,w,h){ return { type:'block', x,y,w,h, passed:false }; }
function makeSpike(x,y,base,orientation='down'){ return { type:'spike', x,y,w:base,h:base, orientation, passed:false }; }
// orientation: 'down' (pointing up from floor) or 'up' (pointing down from ceiling) ‚Äî used for flip
function makeCoin(x,y){ return { x,y,r:G.coinR, taken:false }; }
function makePortal(x,y,kind){ return { type:'portal', x,y,w:56,h:56, kind, triggered:false, passed:false }; }

/* ---------------- Spawn Patterns (fair, varied) ---------------- */
function spawnNormalPattern(baseX){
  // spawn a pattern chosen from a set of 'fair' templates
  const t = G.tile;
  const groundY = Hf() - G.floorH;
  const r = Math.random();
  if(r < 0.2){
    // small staircase with coin on each step, top has spike
    for(let i=0;i<3;i++){
      const h = t * (1 + i);
      const bx = baseX + i * (t*1.9);
      obstacles.push(makeBlock(bx, groundY - h, t*1.6, h));
      coins.push(makeCoin(bx + t*0.8, groundY - h - 18));
      if(i === 2) obstacles.push(makeSpike(bx + t*0.4, groundY - h - t*0.9, t*1.6, 'down'));
    }
  } else if(r < 0.38){
    // three low platforms for hopping
    for(let i=0;i<3;i++){
      const bx = baseX + i * (t*2.6);
      obstacles.push(makeBlock(bx, groundY - t*1.4, t*1.8, t*1.4));
      coins.push(makeCoin(bx + t*0.9, groundY - t*1.4 - 18));
    }
  } else if(r < 0.58){
    // gap + kicker block + forward spike
    obstacles.push(makeSpike(baseX - t*0.6, groundY - t*0.1, t*1.4, 'down'));
    obstacles.push(makeBlock(baseX + t*2.4, groundY - t*2, t*1.8, t*2));
    coins.push(makeCoin(baseX + t*2.4 + t*0.9, groundY - t*2 - 18));
  } else if(r < 0.76){
    // spike wave (pattern) but with gaps so it's fair
    for(let i=0;i<5;i++){
      const sx = baseX + i * (t*1.2);
      obstacles.push(makeSpike(sx, groundY - t*0.1, t*1.5, 'down'));
      if(i % 2 === 0) coins.push(makeCoin(sx + t*0.6, groundY - t*1.6));
    }
  } else {
    // tall block then small block
    obstacles.push(makeBlock(baseX, groundY - t*3, t*1.8, t*3));
    obstacles.push(makeBlock(baseX + t*3.2, groundY - t*1.4, t*1.8, t*1.4));
    coins.push(makeCoin(baseX + t*0.9, groundY - t*3 - 18));
    coins.push(makeCoin(baseX + t*3.2 + t*0.9, groundY - t*1.4 - 18));
  }
}

/* Ship section (narrow tunnel) */
function spawnShipSection(startX){
  const t = G.tile;
  const groundY = Hf() - G.floorH;
  let x = startX;
  const segs = 10;
  for(let i=0;i<segs;i++){
    const topH = t * (1 + Math.floor(Math.random()*2));
    const botH = t * (1 + Math.floor(Math.random()*2));
    obstacles.push(makeBlock(x, 0, t*1.8, topH)); // top wall
    obstacles.push(makeBlock(x, groundY - botH, t*1.8, botH)); // bottom wall
    if(i % 3 === 1) coins.push(makeCoin(x + t*0.9, (topH + (groundY - botH)) / 2));
    x += t*2.0;
  }
  sectionEndX = x + 40;
}

/* Flip section (ceiling-heavy) */
function spawnFlipSection(startX){
  const t = G.tile;
  let x = startX;
  const segs = 10;
  const topBand = t*3;
  for(let i=0;i<segs;i++){
    obstacles.push(makeBlock(x, 0, t*1.8, topBand)); // ceiling band
    if(i % 2 === 0) obstacles.push(makeSpike(x + t*0.2, topBand + t*0.1, t*1.6, 'up')); // hanging spike (orientation up)
    coins.push(makeCoin(x + t*0.9, topBand + t*1.25));
    x += t*2.0;
  }
  sectionEndX = x + 60;
}

/* Spawning controller - robust and never stalls */
let spawnMsAccumulator = 0;
function updateSpawning(dt){
  spawnMsAccumulator += dt;
  // Normal pattern spawn (guaranteed to keep spawning)
  while(!inSection && spawnMsAccumulator >= G.spawnBaseMs){
    spawnMsAccumulator -= G.spawnBaseMs;
    // occasionally spawn denser normal sections
    if(Math.random() < G.normalSectionChance){
      // spawn 2-4 patterns closely
      const count = 2 + Math.floor(Math.random()*3);
      let baseX = Wf() + 220;
      for(let i=0;i<count;i++){
        spawnNormalPattern(baseX + i * (G.tile * 3.6));
      }
    } else {
      spawnNormalPattern(Wf() + 220 + Math.random()*120);
    }
  }

  // chance to start a portal section independently
  if(!inSection && Math.random() < G.portalChance){
    inSection = true;
    const startX = Wf() + 260;
    const kind = Math.random() < 0.5 ? 'ship' : 'flip';
    obstacles.push(makePortal(startX - 80, Hf()/2 - 28, kind));
    if(kind === 'ship') spawnShipSection(startX);
    else spawnFlipSection(startX);
  }

  // finish section if it's passed the player
  if(inSection && sectionEndX < player.x - 80){
    inSection = false;
    // spawn return portal sometimes
    if(Math.random() < 0.8) obstacles.push(makePortal(Wf() + 220, Hf()/2 - 28, 'normal'));
    sectionEndX = Wf() + 220 + 120;
  }

  // keep some spare coins in the world
  if(coins.length < 4 && Math.random() < 0.05){
    coins.push(makeCoin(Wf() + 120 + Math.random()*240, Hf() - G.floorH - G.tile - 18));
  }
}

/* ---------------- Physics & collisions ---------------- */
function updatePhysics(dt){
  // update player according to mode
  if(gameMode === MODE.SHIP){
    // ship: hold to ascend, release to descend
    if(inputPressed) player.vy += G.shipThrust;
    else player.vy += -G.shipThrust * 0.56;
    player.vy = clamp(player.vy, -9, 9);
    player.y += player.vy;
    player.onGround = false;
    // rotate slightly toward input state (cosmetic)
    player.rot = lerp(player.rot, inputPressed ? -0.25 : 0.25, 0.12);
    player.targetRot = player.rot; // keep target consistent
  } else {
    const g = (gameMode === MODE.FLIP) ? -G.gravity : G.gravity;
    player.vy += g * (dt / 16.67);
    player.y += player.vy * (dt / 16.67);
    // rotation behavior: if airborne and jump just started, player.targetRot gets ¬±90¬∞
    // we don't auto-rotate it back ‚Äî player will land at that rotation
    if(!player.onGround){
      // smooth rotation toward targetRot
      player.rot = lerp(player.rot, player.targetRot, 0.18);
    } else {
      // while grounded, keep rot = targetRot (so if landed rotated, stays rotated)
      player.rot = lerp(player.rot, player.targetRot, 0.22);
    }
  }

  // bounds (floor/ceiling)
  const floorY = Hf() - G.floorH - player.h;
  if(gameMode !== MODE.FLIP){
    if(player.y > floorY){ player.y = floorY; player.vy = 0; player.onGround = true; }
    if(player.y < 0){ player.y = 0; player.vy = 0; }
  } else {
    // flipped gravity: 'ceiling' is ground
    if(player.y < 0){ player.y = 0; player.vy = 0; player.onGround = true; }
    if(player.y > floorY){ player.y = floorY; player.vy = 0; }
  }

  // move obstacles
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.x -= speed * (dt / 16.67);

    // portals: trigger mode change when player hits portal AABB
    if(o.type === 'portal' && !o.triggered && AABB(player.x,player.y,player.w,player.h, o.x,o.y,o.w,o.h)){
      o.triggered = true;
      if(o.kind === 'ship'){ gameMode = MODE.SHIP; sfx(1180,0.12,'triangle',0.12); }
      else if(o.kind === 'flip'){ gameMode = MODE.FLIP; sfx(720,0.12,'sine',0.12); }
      else { gameMode = MODE.NORMAL; sfx(520,0.12,'sine',0.12); }
      // when entering a section we may want to ensure spikes orientation respects mode
      for(const ob of obstacles){
        if(ob.type === 'spike'){
          if(gameMode === MODE.FLIP) ob.orientation = 'up';
          else ob.orientation = 'down';
        }
      }
    }

    // scoring: pass obstacles
    const ow = o.w || G.tile;
    if(!o.passed && o.type !== 'portal' && (o.x + ow + 6) < (player.x - 8)){
      o.passed = true;
      score += 1;
      if(score % 10 === 0) speed = Math.min(G.speedMax, speed + 0.25);
      sfx(1400,0.06,'sine',0.08);
      if(score > (state.best||0)) { state.best = score; saveState(); }
    }

    // remove offscreen
    if(o.x + (o.w || 80) < -360) obstacles.splice(i,1);
  }

  // coins movement & pickup
  for(let i = coins.length - 1; i >= 0; i--){
    const c = coins[i]; c.x -= speed * (dt / 16.67);
    if(c.x < -140){ coins.splice(i,1); continue; }
    const dx = player.x + player.w/2 - c.x, dy = player.y + player.h/2 - c.y;
    if(Math.hypot(dx, dy) < (player.w*0.45 + c.r)){
      coins.splice(i,1); state.coins = (state.coins || 0) + 1; sfx(1600,0.08,'sine',0.12); saveState();
    }
  }

  // collisions with obstacles
  for(const ob of obstacles){
    if(ob.type === 'block'){
      resolveBlockCollision(player, ob);
    } else if(ob.type === 'spike'){
      if(checkSpikeCollision(player, ob)) killPlayer();
    }
  }
}

/* Block collision: top vs side logic (top -> stand; side -> die) */
function resolveBlockCollision(p, b){
  if(!AABB(p.x,p.y,p.w,p.h, b.x,b.y,b.w,b.h)) return;
  // compute overlaps
  const leftOverlap = (p.x + p.w) - b.x;
  const rightOverlap = (b.x + b.w) - p.x;
  const topOverlap = (p.y + p.h) - b.y;
  const bottomOverlap = (b.y + b.h) - p.y;
  const minHoriz = Math.min(leftOverlap, rightOverlap);
  const minVert = Math.min(topOverlap, bottomOverlap);
  if(minHoriz < minVert){
    // side collision -> death
    killPlayer();
  } else {
    // vertical collision -> top or bottom
    if(topOverlap < bottomOverlap){
      // landed on top
      p.y = b.y - p.h;
      p.vy = 0;
      p.onGround = true;
      // when landing after a jump, keep the rotation at targetRot (do not reset)
    } else {
      // hit from below
      p.y = b.y + b.h;
      p.vy = 0;
    }
  }
}

/* Spike collision (use simple bounding + triangle test) */
function checkSpikeCollision(p, s){
  // quick reject
  if(!AABB(p.x,p.y,p.w,p.h, s.x, s.y - (s.orientation === 'up' ? s.h*0.9 : 0), s.w, s.h + (s.orientation==='up'? s.h*0.9: 0))) return false;
  // approximate check: check bottom points
  const pts = [
    {x: p.x + p.w*0.1, y: p.y + p.h},
    {x: p.x + p.w*0.9, y: p.y + p.h},
    {x: p.x + p.w/2, y: p.y + p.h}
  ];
  for(const pt of pts){
    if(s.orientation === 'down'){
      if(pointInTriangle(pt.x,pt.y, s.x, s.y + s.h, s.x + s.w/2, s.y, s.x + s.w, s.y + s.h)) return true;
    } else {
      // spike pointing down from ceiling ‚Äî invert triangle
      if(pointInTriangle(pt.x,pt.y, s.x, s.y, s.x + s.w/2, s.y + s.h, s.x + s.w, s.y)) return true;
    }
  }
  return false;
}
function pointInTriangle(px,py, ax,ay, bx,by, cx,cy){
  const area = (P,Q,R)=>Math.abs((P.x*(Q.y-R.y)+Q.x*(R.y-P.y)+R.x*(P.y-Q.y))/2);
  const A = {x:ax,y:ay}, B={x:bx,y:by}, C={x:cx,y:cy}, P={x:px,y:py};
  const A1 = area(P,B,C), A2 = area(A,P,C), A3 = area(A,B,P);
  return Math.abs((A1+A2+A3) - area(A,B,C)) < 0.5;
}

/* ---------------- Kill / restart ---------------- */
function killPlayer(){
  if(!player.alive) return;
  player.alive = false;
  sfx(160,0.22,'sawtooth',0.14);
  if(score > (state.best || 0)) state.best = score;
  saveState();
  // clear world so nothing stacks
  obstacles.length = 0; coins.length = 0; particles.length = 0; speed = G.speedBase;
  setTimeout(()=>{
    document.getElementById('goScore').textContent = score;
    document.getElementById('goBest').textContent = state.best || 0;
    showOverlay('olGO');
    gameState = 'gameover';
  }, 220);
}

/* ---------------- Input handling ---------------- */
function jumpAction(){
  if(gameState === 'menu'){ startGame(); return; }
  if(gameState === 'gameover'){ restartGame(); return; }
  if(gameState !== 'playing') return;

  if(gameMode === MODE.SHIP){
    inputPressed = true;
  } else if(gameMode === MODE.FLIP){
    // inverted gravity: player "jumps" toward ceiling if on ground (ceiling)
    if(player.onGround){
      player.vy = -G.jump * 0.7;
      player.onGround = false;
      // rotate targetRot to -90 degrees (upward)
      player.targetRot = -Math.PI/2;
      sfx(920,0.06,'sine',0.1);
    }
  } else {
    // normal: jump when on ground
    if(player.onGround){
      player.vy = G.jump;
      player.onGround = false;
      // set target rotation by 90deg (clockwise for visual)
      player.targetRot += Math.PI/2;
      // keep targetRot within -PI..PI for stability (optional)
      if(player.targetRot > Math.PI) player.targetRot -= Math.PI*2;
      if(player.targetRot < -Math.PI) player.targetRot += Math.PI*2;
      sfx(960,0.06,'sine',0.11);
    }
  }
}
function releaseAction(){ if(gameMode === MODE.SHIP) inputPressed = false; }

document.addEventListener('keydown', (e)=>{
  if(e.repeat) return;
  if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); jumpAction(); }
  else if(e.code === 'KeyS'){ toggleShop(); }
  else if(e.code === 'KeyP'){ togglePause(); }
  else if(e.code === 'KeyM'){ initAudio(); toggleMute(); }
  else if(e.code === 'KeyR'){ restartGame(); }
});
document.addEventListener('keyup', (e)=>{ if(e.code === 'Space' || e.code === 'ArrowUp') releaseAction(); });

canvas.addEventListener('pointerdown', ()=>{ jumpAction(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
canvas.addEventListener('pointerup', ()=>{ releaseAction(); });
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jumpAction(); }, {passive:false});

/* ---------------- Rendering ---------------- */
function draw(){
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,Hf());
  g.addColorStop(0,'#03040a'); g.addColorStop(1,'#071226');
  ctx.fillStyle = g; ctx.fillRect(0,0,Wf(),Hf());

  // parallax neon blobs
  drawParallax();

  // tile bands (neon squares) - top and bottom
  drawTileBand(0,3); drawTileBand(Hf() - G.floorH, 3);

  // obstacles
  for(const o of obstacles){
    if(o.type === 'block') drawBlock(o);
    else if(o.type === 'spike') drawSpike(o);
    else if(o.type === 'portal') drawPortal(o);
  }

  // coins
  for(const c of coins) drawCoin(c);

  // player
  drawPlayer();

  // particles
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life--;
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0,p.life/40)})`;
    ctx.fillRect(p.x, p.y, 2, 2);
    if(p.life <= 0) particles.splice(i,1);
  }

  // center score
  ctx.font = 'bold 44px Inter, system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillText(score, Wf()/2 + 3, 72 + 3);
  ctx.fillStyle = '#fff'; ctx.fillText(score, Wf()/2, 72);

  // HUD DOM
  document.getElementById('hudScore').textContent = score;
  document.getElementById('hudCoins').textContent = state.coins || 0;
  document.getElementById('hudBest').textContent = state.best || 0;
}

function drawParallax(){
  const t = Date.now() * 0.001;
  for(let i=0;i<6;i++){
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = (i%3===0)?'var(--neon1)':(i%3===1)?'var(--neon2)':'var(--neon3)';
    const x = ((t*30)+i*180) % (Wf()+360) - 180;
    ctx.beginPath(); ctx.ellipse(x, 80 + (i%2)*36, 120, 30, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* draw tile band as neon squares */
function drawTileBand(y,rows=2){
  const t = G.tile;
  for(let r=0;r<rows;r++){
    const yy = y + r * t;
    for(let x = -t; x < Wf() + t; x += t){
      // neon square fill
      const hue = (Math.floor(x/64) % 4);
      const neonColor = (hue === 0) ? getCSSVar('--neon1') : (hue === 1) ? getCSSVar('--neon2') : (hue === 2) ? getCSSVar('--neon3') : getCSSVar('--neon4');
      ctx.fillStyle = neonColor;
      // slightly darker inner square
      ctx.fillRect(x + 2, yy + 2, t - 4, t - 4);
      ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(x + 4, yy + 4, t - 8, t - 8);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.strokeRect(x+0.5, yy+0.5, t-1, t-1);
    }
  }
}
function getCSSVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || '#06b6d4'; }

/* draw block (same look as tiles) */
function drawBlock(b){
  const neonColor = getCSSVar('--neon1');
  ctx.fillStyle = neonColor;
  ctx.fillRect(b.x + 2, b.y + 2, b.w - 4, b.h - 4);
  ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(b.x + 4, b.y + 4, b.w - 8, b.h - 8);
  ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1; ctx.strokeRect(b.x+0.5, b.y+0.5, b.w-1, b.h-1);
  // top lip for depth
  ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(b.x-6, b.y-12, b.w+12, 12);
}

/* draw spike: orientation respected */
function drawSpike(s){
  if(s.orientation === 'down'){
    ctx.fillStyle = '#05060a';
    ctx.beginPath();
    ctx.moveTo(s.x, s.y + s.h);
    ctx.lineTo(s.x + s.w/2, s.y);
    ctx.lineTo(s.x + s.w, s.y + s.h);
    ctx.closePath(); ctx.fill();
    // neon stroke
    const neon = getCSSVar((Math.floor(s.x/64)%3===0)?'--neon1':(Math.floor(s.x/64)%3===1?'--neon2':'--neon3'));
    ctx.strokeStyle = neon; ctx.lineWidth = 2; ctx.stroke();
  } else {
    // spike from ceiling: flip vertically
    ctx.fillStyle = '#05060a';
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x + s.w/2, s.y + s.h);
    ctx.lineTo(s.x + s.w, s.y);
    ctx.closePath(); ctx.fill();
    const neon = getCSSVar((Math.floor(s.x/64)%3===0)?'--neon1':(Math.floor(s.x/64)%3===1?'--neon2':'--neon3'));
    ctx.strokeStyle = neon; ctx.lineWidth = 2; ctx.stroke();
  }
}

function drawPortal(p){
  ctx.save(); ctx.translate(p.x, p.y);
  ctx.fillStyle = p.kind === 'ship' ? '#ffd54f' : (p.kind === 'flip' ? '#7c3aed' : '#60a5fa');
  roundRect(ctx, 0, 0, p.w, p.h, 6); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.22)'; ctx.lineWidth = 2; ctx.strokeRect(0.5, 0.5, p.w-1, p.h-1);
  ctx.restore();
}

function drawCoin(c){
  ctx.save(); ctx.translate(c.x, c.y);
  ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fillStyle = getCSSVar('--gold') || '#f6c84c'; ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(-c.r*0.25, -c.r*0.25, c.r*0.45, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* draw player rectangle using active skin draw if present */
function drawPlayer(){
  ctx.save(); ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.rotate(player.rot);
  // draw offscreen via skin draw function for flexibility
  const skin = skins.find(s => s.id === state.active) || skins[0];
  const off = document.createElement('canvas'); off.width = player.w + 6; off.height = player.h + 6;
  const oc = off.getContext('2d'); oc.translate(3,3);
  // draw a background (neon cube like tile)
  try{ skin.draw(oc, off.width, off.height); }catch(e){}
  ctx.drawImage(off, -off.width/2, -off.height/2);
  ctx.restore();
}

/* ---------------- Game Loop ---------------- */
let lastTs = 0;
function mainLoop(ts){
  if(!lastTs) lastTs = ts;
  const dt = Math.min(60, ts - lastTs); lastTs = ts;

  if(gameState === 'playing'){
    updatePhysics(dt);
    updateSpawning(dt);
  }

  draw();
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

/* ---------------- Game Flow ---------------- */
function startGame(){
  initAudio();
  hideOverlay('olMenu'); hideOverlay('olGO'); hideOverlay('olShop'); hideOverlay('olHelp');
  // reset world
  obstacles = []; coins = []; particles = [];
  score = 0; speed = G.speedBase; inSection = false; sectionEndX = 0;
  gameMode = MODE.NORMAL;
  player.x = 180; player.y = Hf() - G.floorH - player.h; player.vy = 0; player.onGround = true; player.alive = true; player.rot = 0; player.targetRot = 0;
  // pre-spawn a set of patterns so the player has things to pass
  for(let i=0;i<4;i++) spawnNormalPattern(Wf() + 220 + i*420);
  gameState = 'playing';
  canvas.style.pointerEvents = 'auto';
}
function restartGame(){
  hideOverlay('olGO'); startGame();
}
function togglePause(){
  if(gameState === 'playing'){ gameState = 'menu'; showOverlay('olMenu'); }
  else if(gameState === 'menu'){ gameState = 'playing'; hideOverlay('olMenu'); }
}

/* ---------------- Shop UI & Wiring ---------------- */
function buildShop(){
  const grid = document.getElementById('skinGrid'); grid.innerHTML = '';
  for(const s of skins){
    const card = document.createElement('div'); card.className = 'skin-card';
    const prev = document.createElement('div'); prev.className = 'preview';
    prev.appendChild(renderSkinThumb(s.draw, 220, 88));
    const title = document.createElement('div'); title.textContent = `${s.name} ‚Äî ${s.price}ü™ô`; title.style.fontWeight='700';
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px';
    const btn = document.createElement('button');
    if(state.owned.includes(s.id)){
      btn.textContent = state.active === s.id ? 'Aktiv' : 'W√§hlen';
      btn.className = 'ghost';
      btn.disabled = state.active === s.id;
      btn.onclick = ()=>{ state.active = s.id; saveState(); buildShop(); sfx(900,0.06,'sine',0.08); };
    } else {
      btn.textContent = `Kaufen ${s.price}ü™ô`;
      btn.className = 'cta';
      btn.onclick = ()=>{ if((state.coins||0) >= s.price){ state.coins -= s.price; state.owned.push(s.id); saveState(); buildShop(); sfx(980,0.08,'triangle',0.12); } else { sfx(220,0.06,'square',0.1); } };
    }
    row.appendChild(btn); card.appendChild(prev); card.appendChild(title); card.appendChild(row); grid.appendChild(card);
  }
  document.getElementById('shopCoins').textContent = state.coins || 0;
}

/* toggle overlays with pointer-events management to avoid canvas blocking */
function showOverlay(id){
  const el = document.getElementById(id); if(!el) return;
  el.classList.add('show'); el.style.display = 'grid';
  // disable canvas interactions while overlay is up
  canvas.style.pointerEvents = 'none';
}
function hideOverlay(id){
  const el = document.getElementById(id); if(!el) return;
  el.classList.remove('show'); el.style.display = 'none';
  // if no overlay visible, enable canvas
  if(!document.querySelector('.overlay.show')) canvas.style.pointerEvents = 'auto';
}

/* Buttons wiring (fixes: Play & Shop responsive) */
document.getElementById('btnPlay').addEventListener('click', ()=> startGame());
document.getElementById('btnOpenShop').addEventListener('click', ()=> { showOverlay('olShop'); buildShop(); });
document.getElementById('shopClose').addEventListener('click', ()=> hideOverlay('olShop'));
document.getElementById('btnCloseShop').addEventListener('click', ()=> hideOverlay('olShop'));
document.getElementById('btnRestart').addEventListener('click', ()=> restartGame());
document.getElementById('btnGoShop').addEventListener('click', ()=> { hideOverlay('olGO'); showOverlay('olShop'); buildShop(); });
document.getElementById('btnPause').addEventListener('click', ()=> togglePause());
document.getElementById('btnMute').addEventListener('click', ()=> { initAudio(); toggleMute(); });
document.getElementById('btnShop').addEventListener('click', ()=> { showOverlay('olShop'); buildShop(); });
document.getElementById('btnHelp').addEventListener('click', ()=> showOverlay('olHelp'));
document.getElementById('helpClose').addEventListener('click', ()=> hideOverlay('olHelp'));
document.getElementById('helpOk').addEventListener('click', ()=> hideOverlay('olHelp'));
document.getElementById('btnOpenShop').addEventListener('click', ()=> { showOverlay('olShop'); buildShop(); });

// ensure Play always clickable after load (layering race fix)
window.addEventListener('load', ()=>{
  const play = document.getElementById('btnPlay'); play.onclick = ()=> startGame();
  // if menu is visible, ensure canvas pointer events disabled
  if(document.getElementById('olMenu').classList.contains('show')) canvas.style.pointerEvents = 'none';
});

/* keyboard S toggles shop */
function toggleShop(){
  const shop = document.getElementById('olShop');
  if(shop.classList.contains('show')) hideOverlay('olShop'); else { showOverlay('olShop'); buildShop(); }
}

/* overlay background click closes shop/help */
document.getElementById('olShop').addEventListener('click', (e)=>{ if(e.target === document.getElementById('olShop')) hideOverlay('olShop'); });
document.getElementById('olHelp').addEventListener('click', (e)=>{ if(e.target === document.getElementById('olHelp')) hideOverlay('olHelp'); });

/* init audio on first user gesture */
function initAudioOnGesture(){ initAudio(); document.removeEventListener('pointerdown', initAudioOnGesture); }
document.addEventListener('pointerdown', initAudioOnGesture);

/* spawn tick safety (in case main loop stalls) */
setInterval(()=>{ if(gameState === 'playing') updateSpawning(200); }, 200);

/* save state on unload */
window.addEventListener('beforeunload', ()=> saveState());

/* initial HUD */
document.getElementById('hudBest').textContent = state.best || 0;
document.getElementById('hudCoins').textContent = state.coins || 0;

/* ---------------- Utilities ---------------- */
function rand(min,max){ return Math.random()*(max-min) + min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function AABB(ax,ay,aw,ah, bx,by,bw,bh){ return !(ax+aw < bx || bx+bw < ax || ay+ah < by || by+bh < ay); }

/* End of file JS */
</script>
</body>
</html>
