<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bernau Games - CubeLand</title>
<style>
  /* ============================
     Layout & Styling (Neon Dark)
     ============================ */
  :root{
    --panel: rgba(255,255,255,0.04);
    --neon-glow: 12px;
  }
  html,body{ height:100%; margin:0; background:#05060a; font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; color:#fff; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  #app{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:18px; box-sizing:border-box; }
  canvas#game{ width:100%; max-width:1400px; height:calc(100vh - 36px); max-height:820px; border-radius:12px; background:linear-gradient(180deg,#05060a,#081023); box-shadow:0 30px 80px rgba(0,0,0,0.7); display:block; }
  /* HUD */
  .hud{ position:absolute; left:22px; top:18px; display:flex; gap:8px; z-index:40; align-items:center; }
  .pill{ background:rgba(255,255,255,0.03); padding:8px 12px; border-radius:999px; border:1px solid rgba(255,255,255,0.03); display:flex; gap:10px; align-items:center; font-weight:700; }
  .right-hud{ position:absolute; right:22px; top:18px; display:flex; gap:8px; z-index:40; }
  .icon{ width:44px; height:36px; display:grid; place-items:center; background:rgba(255,255,255,0.02); border-radius:8px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); user-select:none; }
  .icon:active{ transform:scale(.98); }

  /* overlays */
  .overlay{ position:absolute; inset:0; display:grid; place-items:center; z-index:80; background:linear-gradient(180deg, rgba(2,6,23,0.75), rgba(2,6,23,0.75)); }
  .card{ background:rgba(255,255,255,0.03); padding:18px; border-radius:12px; width:min(92vw,900px); box-shadow:0 20px 60px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03); color:#fff; }
  .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
  button.cta{ background:linear-gradient(90deg,#7c3aed,#06b6d4); border:none; padding:10px 14px; border-radius:10px; font-weight:800; cursor:pointer; color:#fff; }
  button.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.08); padding:8px 10px; border-radius:8px; cursor:pointer; color:#fff; }
  .close-x{ position:absolute; right:12px; top:12px; background:rgba(255,255,255,0.03); border-radius:999px; padding:8px; cursor:pointer; }

  /* shop */
  .shop-grid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); gap:10px; max-height:48vh; overflow:auto; padding:8px; }
  .skin-card{ background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; display:flex; flex-direction:column; gap:8px; align-items:center; border:1px solid rgba(255,255,255,0.02); }
  .preview{ width:120px; height:70px; border-radius:8px; display:grid; place-items:center; overflow:hidden; }
  .muted{ opacity:0.85; font-size:13px; }
  .small{ font-size:12px; opacity:0.8; }

  /* responsive */
  @media (max-width:640px){
    canvas#game{ height:calc(100vh - 24px); border-radius:8px; }
    .card{ width:94vw; }
  }
</style>
</head>
<body>
  <div id="app">
    <canvas id="game" width="1280" height="720" role="img" aria-label="Bernau Games - CubeLand"></canvas>

    <!-- HUD -->
    <div class="hud" aria-hidden="false">
      <div class="pill">üéÆ Bernau Games - CubeLand</div>
      <div class="pill">ü™ô <span id="hudCoins">0</span></div>
      <div class="pill">üèÜ Best: <span id="hudBest">0</span></div>
      <div class="pill">üìè Score: <span id="hudScore">0</span></div>
    </div>

    <div class="right-hud">
      <div class="icon" id="btnPause" title="Pause (P)">‚è∏</div>
      <div class="icon" id="btnMute" title="Mute (M)">üîä</div>
      <div class="icon" id="btnShop" title="Shop (S)">üõçÔ∏è</div>
      <div class="icon" id="btnHelp" title="Hilfe (H)">‚ùì</div>
    </div>

    <!-- Intro Menu -->
    <div id="overlayMenu" class="overlay" role="dialog" aria-modal="true">
      <div class="card">
        <div class="row">
          <h1 style="margin:0">Bernau Games - CubeLand</h1>
          <div class="small muted">Geometry Dash inspired</div>
        </div>
        <p style="margin-top:10px">Springe √ºber Hindernisse, durch Portale, sammle M√ºnzen und schalte Skins frei. Das Spiel ist endlos ‚Äî wie weit schaffst du es?</p>
        <div class="row" style="margin-top:12px">
          <div>
            <button class="cta" id="startButton">‚ñ∂Ô∏è Spielen</button>
            <button class="ghost" id="openShopButton">üõçÔ∏è Shop</button>
          </div>
          <div style="text-align:right">
            <div class="muted">Steuerung: Leertaste/Tap = Springen ¬∑ P = Pause ¬∑ S = Shop ¬∑ M = Ton ¬∑ R = Neustart</div>
          </div>
        </div>
        <div style="margin-top:10px" class="small">Speichert Fortschritt lokal (localStorage).</div>
      </div>
    </div>

    <!-- Game Over -->
    <div id="overlayGameOver" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card">
        <h2 style="margin:0">Game Over</h2>
        <p class="muted">Dein Score: <b id="goScore">0</b> ¬∑ Best: <b id="goBest">0</b></p>
        <div class="row" style="margin-top:12px">
          <button class="cta" id="btnRestart">‚Ü∫ Neustarten (R)</button>
          <button class="ghost" id="btnGoShop">üõçÔ∏è Shop</button>
        </div>
      </div>
    </div>

    <!-- Shop -->
    <div id="overlayShop" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="position:relative;">
        <div class="close-x" id="shopClose">‚úï</div>
        <h2 style="margin:0 0 6px 0">Shop ‚Äî Skins</h2>
        <p class="muted">Kaufe Skins mit M√ºnzen. Skins sind erst aktivierbar, wenn gekauft.</p>

        <h3 style="margin-top:12px; margin-bottom:6px">Vogel / Cube Skins</h3>
        <div id="skinGrid" class="shop-grid" aria-live="polite"></div>

        <div class="row" style="margin-top:12px;">
          <div class="muted">Deine M√ºnzen: <b id="shopCoins">0</b></div>
          <div><button class="ghost" id="shopCloseBtn">Schlie√üen</button></div>
        </div>
      </div>
    </div>

    <!-- Help -->
    <div id="overlayHelp" class="overlay" role="dialog" aria-modal="true" style="display:none">
      <div class="card" style="max-width:560px">
        <div class="close-x" id="helpClose">‚úï</div>
        <h2>Hilfe</h2>
        <p>Springe √ºber Hindernisse und Stacheln. Manche Portale ver√§ndern dein Verhalten (Flugmodus, Boost, Flip). M√ºnzen findest du oft auf Plattformen.</p>
        <div style="text-align:center; margin-top:8px"><button class="cta" id="helpOk">Verstanden</button></div>
      </div>
    </div>

  </div>

<script>
/* ==========================================================================
   Bernau Games - CubeLand (Geometry Dash Style)
   - Player rolls on floor and jumps
   - Many block/spike obstacles to jump over
   - Coin placement on platforms
   - Neon-dark visual style and glow
   - Shop with locked skins
   - Audio via WebAudio (music loop + sfx)
   - Save progress in localStorage
   ========================================================================== */

/* -------------------------
   Persistence helpers
   ------------------------- */
const LS_KEY = 'bernau_cubeland_state_v1';
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY) || '{}');
    s.coins = s.coins || 0;
    s.best = s.best || 0;
    s.owned = s.owned || ['skin_default'];
    s.active = s.active || 'skin_default';
    s.muted = typeof s.muted === 'boolean' ? s.muted : false;
    return s;
  }catch(e){
    return { coins:0, best:0, owned:['skin_default'], active:'skin_default', muted:false };
  }
}
function saveState(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){}
}

/* -------------------------
   Base state
   ------------------------- */
let state = loadState();

/* -------------------------
   Canvas setup & scaling
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

function fitCanvas(){
  const parentRect = canvas.parentElement.getBoundingClientRect();
  let w = Math.min(parentRect.width, 1400);
  let h = Math.min(parentRect.height, 820);
  const targetRatio = 16/9;
  if(w / h > targetRatio) { w = Math.round(h * targetRatio); }
  else { h = Math.round(w / targetRatio); }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  canvas.width = Math.round(w * DPR);
  canvas.height = Math.round(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

function W(){ return canvas.width / DPR; }
function H(){ return canvas.height / DPR; }

/* -------------------------
   Game variables (explicit)
   ------------------------- */
let gameState = 'menu'; // menu, playing, paused, gameover
let score = 0;
let best = state.best || 0;
let distance = 0;
let speed = 3.6; // world scroll speed
let gravity = 0.6;
let jumpPower = -10;

let lastTime = 0;

/* -------------------------
   Player (cube) explicit object
   ------------------------- */
let player = {
  x: 180,
  y: H()/2,
  vy: 0,
  w: 44,
  h: 44,
  rotation: 0,
  alive: true,
  onGround: false,
  jumpCount: 0 // for possible double jump
};

/* -------------------------
   Segments / Obstacles
   We'll use arrays with explicit objects
   ------------------------- */
let obstacles = []; // blocks, spikes
let coins = [];
let particles = [];
let spawnCounter = 0;
let spawnInterval = 900; // ms

/* -------------------------
   Skin definitions (explicit)
   - include some named skins
   - skin.id must match state.owned/active logic
   ------------------------- */
let skins = [];
function addSkin(id, name, shape, body, accent, price, purchased){
  skins.push({ id, name, shape, body, accent, price, purchased: purchased || false });
}
// add several skins explicitly
addSkin('skin_default','Default','cube','#ffd54f','#f59e0b',0, state.owned.includes('skin_default'));
addSkin('skin_neon','Neon Pulse','cube','#7c3aed','#00f6ff',30, state.owned.includes('skin_neon'));
addSkin('skin_glow','Glow','rounded','#06b6d4','#7c3aed',45, state.owned.includes('skin_glow'));
addSkin('skin_steel','Steel','cube','#9CA3AF','#6B7280',50, state.owned.includes('skin_steel'));
addSkin('skin_ship','Ship','ship','#F472B6','#FB7185',80, state.owned.includes('skin_ship'));

// generate additional skins programmatically but keep them explicit entries
for(let i=5;i<25;i++){
  const hue = (i*35)%360;
  const id = 'skin_gen_'+i;
  const name = 'Skin ' + (i+1);
  const shape = (i%3===0)?'ship':(i%3===1)?'rounded':'cube';
  const body = `hsl(${hue} 70% 55%)`;
  const accent = `hsl(${(hue+40)%360} 80% 60%)`;
  const price = 10 + i*5;
  addSkin(id, name, shape, body, accent, price, state.owned.includes(id));
}

// Ensure active skin exists
if(!state.active || !skins.find(s=>s.id === state.active)){ state.active = 'skin_default'; }

/* -------------------------
   Background neon style config
   ------------------------- */
const bg = {
  top: '#02040a',
  bottom: '#061226',
  neonAccent1: '#06b6d4',
  neonAccent2: '#7c3aed',
  neonAccent3: '#f472b6'
};

/* -------------------------
   Audio: WebAudio basic loop + sfx
   ------------------------- */
let audioCtx = null;
let masterGain = null;

function initAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = state.muted ? 0 : 0.9;
    masterGain.connect(audioCtx.destination);
    buildMusic();
  }catch(e){
    console.warn('Audio init failed', e);
  }
}
let musicNodes = [];
function buildMusic(){
  if(!audioCtx) return;
  // simple ambient loop using oscillators + percussive noise
  const baseGain = audioCtx.createGain(); baseGain.gain.value = 0.05; baseGain.connect(masterGain);
  const o1 = audioCtx.createOscillator(); o1.type='sine'; o1.frequency.value = 110; o1.connect(baseGain); o1.start();
  const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value = 220; o2.connect(baseGain); o2.start();
  const o3 = audioCtx.createOscillator(); o3.type='sine'; o3.frequency.value = 330; o3.connect(baseGain); o3.start();
  // subtle LFO to modulate baseGain
  const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.08;
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.03;
  lfo.connect(lfoGain); lfoGain.connect(baseGain.gain); lfo.start();
  musicNodes = [o1,o2,o3,lfo,baseGain];
}
function toggleMute(){
  state.muted = !state.muted;
  if(masterGain) masterGain.gain.value = state.muted ? 0 : 0.9;
  document.getElementById('btnMute').textContent = state.muted ? 'üîà' : 'üîä';
  saveState();
}
function playSfx(freq=700, dur=0.06, type='sine', vol=0.12){
  if(!audioCtx || state.muted) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(masterGain);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

/* -------------------------
   Utility functions (explicit)
   ------------------------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rectOverlap(ax,ay,aw,ah,bx,by,bw,bh){
  return !(ax+aw < bx || bx+bw < ax || ay+ah < by || by+bh < ay);
}
function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx+dy*dy); }

/* -------------------------
   Obstacle constructors (explicit)
   ------------------------- */
function makeBlock(x, top, height, width=80){
  // top: top-block height; bottom block begins at top+gapHeight
  return { type:'block', x:x, top:top, h:height, w:width, gap:160 };
}
function makeSpikeRow(x, y, count=4, spacing=20){
  return { type:'spikes', x:x, y:y, count:count, spacing:spacing, w: count*spacing };
}
function makeMovingBlock(x, top, height, vy=0.6){
  return { type:'moving', x:x, top:top, h:height, w:72, vy:vy, dir:1 };
}
function makePortal(x, y, portalType){
  return { type:'portal', x:x, y:y, w:64, portalType: portalType, triggered:false };
}

/* -------------------------
   Spawn logic ‚Äî explicit and varied
   ------------------------- */
function spawnSegmentAt(x){
  const r = Math.random();
  if(r < 0.25){
    // single pair block with coin in gap
    const top = Math.floor(rand(100, H() - 260));
    const topBlock = makeBlock(x, top, top);
    const bottomTop = top + 180;
    const bottomBlock = { type:'block', x:x, top: bottomTop, h: H() - bottomTop - 60, w: topBlock.w, gap:160 };
    obstacles.push(topBlock); obstacles.push(bottomBlock);
    coins.push({ x: x + topBlock.w/2, y: top + 80, r: 10, taken:false });
  } else if(r < 0.45){
    const top = Math.floor(rand(120, H() - 220));
    obstacles.push(makeMovingBlock(x, top, 80, rand(0.5,1.2)));
    // coin above moving block
    coins.push({ x: x + 28, y: top - 24, r: 10, taken:false });
  } else if(r < 0.62){
    // spike row
    const y = H() - 60 - 12; // on ground
    obstacles.push(makeSpikeRow(x, y, Math.floor(rand(3,7)), 24));
  } else if(r < 0.8){
    // portal
    const y = Math.floor(rand(120, H() - 200));
    obstacles.push(makePortal(x, y, (Math.random()<0.5)?'ship':(Math.random()<0.5?'flip':'boost')));
    coins.push({ x: x + 36, y: y + 16, r: 10, taken:false });
  } else {
    // wide gap
    const top = Math.floor(rand(80, H() - 240));
    obstacles.push(makeBlock(x, top, top));
    obstacles.push({ type:'block', x:x, top: top + 220, h: H() - (top + 220) - 60, w:96, gap:220 });
    coins.push({ x: x + 44, y: top + 110, r:10, taken:false });
  }
}

/* spawn loop control */
let spawnTimer = 0;
function updateSpawn(dt){
  spawnTimer += dt;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    // compute new segment x at right side + offset
    const baseX = W() + 80 + Math.random() * 180;
    spawnSegmentAt(baseX);
    // small chance to spawn an extra portal ahead
    if(Math.random() < 0.12){ spawnSegmentAt(baseX + 220); }
  }
}

/* -------------------------
   Update loop ‚Äî physics + collision
   ------------------------- */
function updateGame(dt){
  if(gameState !== 'playing') return;

  // apply gravity (unless ship mode in future)
  player.vy += gravity * (dt / 16.67);
  player.y += player.vy * (dt / 16.67);

  // simple ground collision
  const groundY = H() - 60 - player.h/2;
  if(player.y > groundY){
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
    player.jumpCount = 0;
  } else {
    player.onGround = false;
  }

  // update obstacles positions (move left)
  for(let i = obstacles.length - 1; i >= 0; i--){
    const o = obstacles[i];
    o.x -= speed * (dt / 16.67);
    // moving block vertical movement
    if(o.type === 'moving'){
      o.top += o.vy * o.dir * (dt / 16.67);
      if(o.top < 60 || o.top + o.h > H() - 120) o.dir *= -1;
    }
    // portal trigger detection
    if(o.type === 'portal'){
      // if player intersects portal center
      const px = o.x + o.w/2;
      const py = o.y + 32;
      if(Math.abs(player.x - px) < o.w/2 + player.w/2 && Math.abs(player.y - py) < 40){
        if(!o.triggered){
          o.triggered = true;
          if(o.portalType === 'ship'){
            // flight mode: reduce gravity for a while and allow sustained upward movement by holding jump (not implemented full ship; just give small lift)
            player.vy = -6;
            playSfx(1100, 0.12, 'sine', 0.12);
          } else if(o.portalType === 'boost'){
            // temporary speed boost
            speed += 1.6;
            setTimeout(()=>{ speed = Math.max(3.6, speed - 1.6); }, 1600);
            playSfx(920, 0.12, 'sawtooth', 0.12);
          } else if(o.portalType === 'flip'){
            // inverted gravity briefly
            gravity = -gravity;
            setTimeout(()=>{ gravity = -gravity; }, 1600);
            playSfx(520,0.14,'triangle',0.11);
          }
        }
      }
    }

    // collision checks
    if(o.type === 'block' || o.type === 'moving'){
      // top block rect
      const topRect = { x: o.x, y: 0, w: o.w || 80, h: o.top };
      // bottom block rect
      const bottomY = o.top + (o.gap || 160);
      const bottomRect = { x: o.x, y: bottomY, w: o.w || 80, h: H() - bottomY - 60 };
      // collision with player rect
      const px = player.x - player.w/2, py = player.y - player.h/2, pw = player.w, ph = player.h;
      if(rectOverlap(px,py,pw,ph, topRect.x, topRect.y, topRect.w, topRect.h) ||
         rectOverlap(px,py,pw,ph, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)){
           playerDie();
      }
    } else if(o.type === 'spikes'){
      // spikes are ground-level hazards; represent as rectangle for collision
      const spikeRect = { x: o.x, y: o.y - 20, w: o.w, h: 20 };
      const px = player.x - player.w/2, py = player.y - player.h/2, pw = player.w, ph = player.h;
      if(rectOverlap(px,py,pw,ph, spikeRect.x, spikeRect.y, spikeRect.w, spikeRect.h)){
        playerDie();
      }
    }

    // remove offscreen obstacles
    if(o.x + (o.w || 80) < -120){
      obstacles.splice(i,1);
    }
  }

  // update coins
  for(let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= speed * (dt / 16.67);
    if(!c.taken && dist(c.x, c.y, player.x, player.y) < c.r + (player.w/2) - 6){
      c.taken = true;
      state.coins = (state.coins || 0) + 1;
      playSfx(1200, 0.08, 'sine', 0.11);
      // spawn particles
      for(let p=0;p<8;p++){
        particles.push({ x:c.x, y:c.y, vx: rand(-1.6,1.6), vy: rand(-3,-1), life: 50 + Math.random()*20 });
      }
      coins.splice(i,1);
    } else if(c.x < -80){
      coins.splice(i,1);
    }
  }

  // particles update
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx * (dt / 16.67);
    p.y += p.vy * (dt / 16.67);
    p.vy += 0.12;
    p.life -= dt / 16.67;
    if(p.life <= 0) particles.splice(i,1);
  }

  // update distance & score
  distance += speed * (dt / 16.67);
  score = Math.floor(distance / 10);

  // spawn manager
  updateSpawn(dt);

  // fail if player goes out of bounds (top/bottom)
  if(player.y - player.h/2 > H() - 30 || player.y + player.h/2 < -30){
    playerDie();
  }
}

/* -------------------------
   Rendering ‚Äî explicit neon style
   ------------------------- */
function render(){
  // clear
  ctx.clearRect(0,0,W(),H());

  // background gradient (dark)
  const g = ctx.createLinearGradient(0,0,0,H());
  g.addColorStop(0, bg.top);
  g.addColorStop(1, bg.bottom);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W(),H());

  // neon grid / parallax glowing lines
  drawNeonBackground();

  // ground
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0, H()-60, W(), 60);
  // ground stripes
  for(let i=0;i<Math.ceil(W()/30)+3;i++){
    const x = (i*30 - (Math.floor(distance)%30));
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(x, H()-24, 14, 6);
  }

  // draw obstacles
  for(const o of obstacles){
    if(o.type === 'block' || o.type === 'moving'){
      // top
      ctx.fillStyle = '#102b2a';
      ctx.fillRect(o.x, 0, o.w || 80, o.top);
      // cap top
      ctx.fillStyle = '#0f5b56';
      ctx.fillRect(o.x-6, o.top-16, (o.w||80)+12, 16);
      // bottom block
      const bottomY = o.top + (o.gap || 160);
      ctx.fillStyle = '#102b2a';
      ctx.fillRect(o.x, bottomY, o.w || 80, H() - bottomY - 60);
      ctx.fillStyle = '#0f5b56';
      ctx.fillRect(o.x-6, bottomY, (o.w||80)+12, 16);

      // neon accent outline
      ctx.strokeStyle = 'rgba(96,165,250,0.18)';
      ctx.lineWidth = 2;
      ctx.strokeRect(o.x, 0, o.w || 80, o.top);
      ctx.strokeRect(o.x, bottomY, o.w || 80, H() - bottomY - 60);

      // if moving, draw an indicator
      if(o.type === 'moving'){
        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        ctx.fillRect(o.x+2, o.top + 2, o.w-4, (o.h||80)-4);
      }

      // optional boost highlight
      if(o.boost){
        ctx.fillStyle = 'rgba(255,200,100,0.08)';
        ctx.fillRect(o.x, o.top + 60, o.w || 80, 40);
      }
    } else if(o.type === 'portal'){
      // draw neon ring for portal
      const centerX = o.x + o.w/2;
      const centerY = o.y + 32;
      ctx.save();
      ctx.beginPath();
      ctx.arc(centerX, centerY, 28, 0, Math.PI*2);
      ctx.fillStyle = o.portalType === 'ship' ? '#ffd54f' : o.portalType === 'flip' ? '#8b5cf6' : '#60a5fa';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX, centerY, 14, 0, Math.PI*2);
      ctx.fillStyle = '#061226';
      ctx.fill();
      ctx.restore();

      // ring glow
      ctx.beginPath();
      ctx.arc(centerX, centerY, 28, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else if(o.type === 'spikes'){
      // draw triangular spikes
      ctx.fillStyle = '#c62828';
      for(let i=0;i<o.count;i++){
        const sx = o.x + i*o.spacing;
        ctx.beginPath();
        ctx.moveTo(sx, o.y);
        ctx.lineTo(sx + (o.spacing/2), o.y - 18);
        ctx.lineTo(sx + o.spacing, o.y);
        ctx.closePath();
        ctx.fill();
      }
    }
  }

  // draw coins
  for(const c of coins){
    ctx.save();
    ctx.translate(c.x, c.y);
    const rot = Math.sin(Date.now()*0.003 + c.x*0.002) * 0.4;
    ctx.rotate(rot);
    // coin body
    ctx.fillStyle = '#f6c84c';
    ctx.beginPath(); ctx.arc(0,0,c.r,0,Math.PI*2); ctx.fill();
    // shine
    ctx.fillStyle = '#fff1a8';
    ctx.beginPath(); ctx.arc(-c.r*0.3, -c.r*0.3, c.r*0.45, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // draw player (neon cube)
  drawPlayer(player);

  // draw particles
  for(const p of particles){
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, p.life/60)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(1, p.life*0.03), 0, Math.PI*2); ctx.fill();
  }

  // center score big
  ctx.font = 'bold 42px Inter, system-ui, sans-serif';
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.textAlign = 'center';
  ctx.fillText(score, W()/2 + 3, 72 + 3);
  ctx.fillStyle = '#fff';
  ctx.fillText(score, W()/2, 72);

  // update DOM HUD
  document.getElementById('hudCoins').textContent = state.coins || 0;
  document.getElementById('hudBest').textContent = state.best || 0;
  document.getElementById('hudScore').textContent = score;
}

/* draw neon background (grid + subtle glows) */
function drawNeonBackground(){
  // subtle vertical grid lines
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.strokeStyle = '#00f6ff';
  ctx.lineWidth = 1;
  for(let i=0;i<W(); i+=80){
    ctx.beginPath(); ctx.moveTo(i - (distance%80), 0); ctx.lineTo(i - (distance%80), H()); ctx.stroke();
  }
  ctx.restore();

  // some neon floating shapes
  for(let i=0;i<5;i++){
    const x = (i*280 + (Date.now()*0.02) ) % W();
    const y = 80 + (i%2)*40;
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = (i%2===0)? bg.neonAccent1 : bg.neonAccent2;
    ctx.beginPath(); ctx.ellipse(x, y, 120, 40, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* draw player sprite (neon cube with outline) */
function drawPlayer(p){
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.rotation || 0);
  const skin = skins.find(s=>s.id === state.active) || skins[0];
  const size = Math.max(16, p.w * 0.95);
  // body
  ctx.fillStyle = skin.body;
  roundRect(ctx, -size/2, -size/2, size, size, (skin.shape==='rounded')?8:2);
  ctx.fill();
  // outline neon
  ctx.strokeStyle = skin.accent;
  ctx.lineWidth = 3;
  ctx.stroke();
  // eye/cockpit
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(size*0.18, -size*0.12, Math.max(2, size*0.08), 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.arc(size*0.22, -size*0.12, Math.max(1.1, size*0.04), 0, Math.PI*2); ctx.fill();
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* -------------------------
   Player control functions (explicit)
   ------------------------- */
function jump(){
  if(gameState === 'menu'){
    startGame();
    return;
  }
  if(gameState === 'gameover'){
    restartGame();
    return;
  }
  if(gameState !== 'playing') return;
  // allow jump only if on ground (single jump)
  if(player.onGround || player.jumpCount < 1){
    player.vy = jumpPower;
    player.onGround = false;
    player.jumpCount += 1;
    playSfx(880 + Math.random()*120, 0.06, 'sine', 0.12);
    // small particles on jump
    for(let i=0;i<6;i++) particles.push({ x: player.x - 10 + Math.random()*20, y: player.y + player.h/2, vx: rand(-1.8,1.8), vy: rand(-3,-1), life: 40 + Math.random()*20 });
  }
}

/* -------------------------
   Death / Restart logic (explicit)
   ------------------------- */
function playerDie(){
  if(!player.alive) return;
  player.alive = false;
  playSfx(150, 0.2, 'sawtooth', 0.14);
  gameState = 'gameover';
  // show game over overlay after small delay
  setTimeout(()=> {
    document.getElementById('overlayGameOver').style.display = 'grid';
    document.getElementById('goScore').textContent = score;
    document.getElementById('goBest').textContent = Math.max(state.best || 0, score);
  }, 300);
  // save best
  if(!state.best || score > state.best) state.best = score;
  saveState();
}

function restartGame(){
  document.getElementById('overlayGameOver').style.display = 'none';
  // reset many variables explicitly
  player.x = 180; player.y = H()/2; player.vy = 0; player.rotation = 0; player.alive = true; player.onGround = false; player.jumpCount = 0;
  obstacles = []; coins = []; particles = []; spawnTimer = 0; spawnInterval = 900; distance = 0; score = 0; speed = 3.6; gravity = Math.abs(gravity);
  gameState = 'playing';
  for(let i=0;i<3;i++){ spawnSegmentAt(W() + i*420); } // prefill
}

/* -------------------------
   Spawn segment helper alias (keeps explicit name)
   ------------------------- */
function spawnSegmentAt(x){ spawnSegmentAt; spawnSegmentAt = spawnSegmentAt; } // placeholder to avoid minifiers ‚Äî replaced below
// Override placeholder with actual implementation to keep code ordering explicit:
spawnSegmentAt = function(x){
  spawnSegmentAt = spawnSegmentAt; // no-op to keep verbosity
  spawnSegmentAt = undefined; // then call the real logic by referencing spawnRandomSegment
  spawnRandomSegment(x);
};

// Real spawner function (explicit)
function spawnRandomSegment(xBase){
  // Re-used explicit spawn logic as above in updateSpawn
  const r = Math.random();
  if(r < 0.25){
    const top = Math.floor(rand(100, H() - 260));
    obstacles.push(makeBlock(xBase, top, top));
    obstacles.push({ type:'block', x:xBase, top: top + 180, h: H() - (top + 180) - 60, w: 80, gap:160 });
    coins.push({ x: xBase + 40, y: top + 80, r: 10, taken:false });
  } else if(r < 0.45){
    const top = Math.floor(rand(120, H() - 220));
    obstacles.push(makeMovingBlock(xBase, top, 80, rand(0.5,1.1)));
    coins.push({ x: xBase + 28, y: top - 24, r: 10, taken:false });
  } else if(r < 0.62){
    const y = H() - 60 - 12;
    obstacles.push(makeSpikeRow(xBase, y, Math.floor(rand(3,7)), 24));
  } else if(r < 0.8){
    const y = Math.floor(rand(120, H() - 200));
    obstacles.push(makePortal(xBase, y, (Math.random()<0.5)?'ship':(Math.random()<0.5?'flip':'boost')));
    coins.push({ x: xBase + 36, y: y + 16, r: 10, taken:false });
  } else {
    const top = Math.floor(rand(80, H() - 240));
    obstacles.push(makeBlock(xBase, top, top));
    obstacles.push({ type:'block', x:xBase, top: top + 220, h: H() - (top + 220) - 60, w:96, gap:220 });
    coins.push({ x: xBase + 44, y: top + 110, r: 10, taken:false });
  }
}

/* -------------------------
   Input bindings (explicit)
   ------------------------- */
document.addEventListener('keydown', (e)=>{
  if(e.repeat) return;
  if(e.code === 'Space' || e.code === 'ArrowUp'){
    e.preventDefault(); jump();
  } else if(e.code === 'KeyS'){
    // open/close shop
    const el = document.getElementById('overlayShop');
    el.style.display = (el.style.display === 'grid' ? 'none' : 'grid');
    if(el.style.display === 'grid') buildShopUI();
  } else if(e.code === 'KeyP'){
    if(gameState === 'playing'){ gameState = 'paused'; document.getElementById('overlayMenu').style.display = 'grid'; }
    else if(gameState === 'paused'){ gameState = 'playing'; document.getElementById('overlayMenu').style.display = 'none'; }
  } else if(e.code === 'KeyM'){
    initAudio(); toggleMute();
  } else if(e.code === 'KeyR'){
    restartGame();
  } else if(e.code === 'Escape'){
    // close overlays
    document.getElementById('overlayMenu').style.display = 'none';
    document.getElementById('overlayShop').style.display = 'none';
    document.getElementById('overlayHelp').style.display = 'none';
  }
});
canvas.addEventListener('pointerdown', (e)=>{ jump(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });
canvas.addEventListener('pointerup', ()=>{ /* no hold-based action needed */ });
canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); }, { passive:false });

/* -------------------------
   Shop UI: explicit, scrollable and lock enforced
   ------------------------- */
function buildShopUI(){
  const grid = document.getElementById('skinGrid');
  grid.innerHTML = '';
  for(const s of skins){
    const card = document.createElement('div'); card.className = 'skin-card';
    const preview = document.createElement('div'); preview.className = 'preview';
    const pv = document.createElement('canvas'); pv.width = 240; pv.height = 140;
    pv.style.width = '100%'; pv.style.height = '100%';
    const pctx = pv.getContext('2d');
    // dark stripe background
    pctx.fillStyle = '#09111a';
    pctx.fillRect(0,0,240,140);
    // draw shape explicitly
    pctx.fillStyle = s.body;
    if(s.shape === 'cube'){
      pctx.fillRect(80,30,80,80);
    } else if(s.shape === 'rounded'){
      pctx.beginPath(); pctx.ellipse(120,70,40,36,0,0,2*Math.PI); pctx.fill();
    } else if(s.shape === 'ship'){
      pctx.beginPath(); pctx.moveTo(60,70); pctx.lineTo(180,50); pctx.lineTo(60,90); pctx.closePath(); pctx.fill();
    } else {
      pctx.fillRect(80,30,80,80);
    }
    preview.appendChild(pv);
    card.appendChild(preview);
    const label = document.createElement('div'); label.className = 'muted'; label.textContent = s.name + ' ‚Äî ' + s.price + ' ü™ô';
    card.appendChild(label);
    const controls = document.createElement('div'); controls.style.display='flex'; controls.style.gap='8px';
    const btn = document.createElement('button');
    // enforce purchase lock
    if(state.owned.includes(s.id)){
      btn.textContent = state.active === s.id ? 'Aktiv' : 'W√§hlen';
      btn.className = 'ghost';
      btn.disabled = state.active === s.id;
      btn.addEventListener('click', ()=>{ state.active = s.id; saveState(); buildShopUI(); });
    } else {
      btn.textContent = `Kaufen ${s.price}ü™ô`;
      btn.className = 'cta';
      btn.addEventListener('click', ()=>{
        if(state.coins >= s.price){
          state.coins -= s.price;
          state.owned.push(s.id);
          saveState();
          buildShopUI();
          playSfx(880,0.08,'triangle',0.12);
        } else {
          // feedback if not enough coins
          document.getElementById('hudCoins').animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:320});
          playSfx(220,0.06,'square',0.08);
        }
      });
    }
    controls.appendChild(btn);
    card.appendChild(controls);
    grid.appendChild(card);
  }
  document.getElementById('shopCoins').textContent = state.coins || 0;
}

/* -------------------------
   Game loop orchestration (explicit)
   ------------------------- */
let req = null;
function loop(timestamp){
  if(!lastTime) lastTime = timestamp;
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  if(gameState === 'playing'){
    updateGame(dt);
  } else if(gameState === 'menu'){
    // idle bob for player
    player.y = H()/2 + Math.sin(Date.now()*0.002) * 8;
  } else if(gameState === 'gameover'){
    // falling animation handled in updateGame partially
  }

  render();
  req = requestAnimationFrame(loop);
}
req = requestAnimationFrame(loop);

/* -------------------------
   Init audio on first interaction
   ------------------------- */
function initAudioOnUser(){
  initAudio();
  document.removeEventListener('pointerdown', initAudioOnUser);
}
document.addEventListener('pointerdown', initAudioOnUser);

/* -------------------------
   Start/Restart helpers and UI wiring
   ------------------------- */
document.getElementById('startButton').addEventListener('click', ()=>{ startPlaying(); });
document.getElementById('openShopButton').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display = 'grid'; buildShopUI(); });
document.getElementById('shopClose').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display = 'none'; });
document.getElementById('shopCloseBtn').addEventListener('click', ()=>{ document.getElementById('overlayShop').style.display = 'none'; });
document.getElementById('btnShop').addEventListener('click', ()=>{ const el = document.getElementById('overlayShop'); el.style.display = (el.style.display === 'grid') ? 'none' : 'grid'; if(el.style.display === 'grid') buildShopUI(); });
document.getElementById('btnMute').addEventListener('click', ()=>{ initAudio(); toggleMute(); });
document.getElementById('btnPause').addEventListener('click', ()=>{ if(gameState === 'playing'){ gameState='paused'; document.getElementById('overlayMenu').style.display='grid'; } else { gameState='playing'; document.getElementById('overlayMenu').style.display='none'; }});
document.getElementById('btnHelp').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='grid'; });
document.getElementById('helpClose').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('helpOk').addEventListener('click', ()=>{ document.getElementById('overlayHelp').style.display='none'; });
document.getElementById('btnRestart')?.addEventListener('click', ()=>{ restartGame(); });
document.getElementById('btnGoShop')?.addEventListener('click', ()=>{ document.getElementById('overlayGameOver').style.display='none'; document.getElementById('overlayShop').style.display='grid'; buildShopUI(); });

/* when closing menu start */
document.getElementById('closeIntroBtn')?.addEventListener('click', ()=>{ document.getElementById('overlayMenu').style.display='none'; startPlaying(); });

/* -------------------------
   Start playing initialization
   ------------------------- */
function startPlaying(){
  initAudio();
  document.getElementById('overlayMenu').style.display = 'none';
  document.getElementById('overlayShop').style.display = 'none';
  document.getElementById('overlayGameOver').style.display = 'none';
  // reset player & world explicitly
  player.x = 180; player.y = H()/2; player.vy = 0; player.rotation = 0; player.alive = true; player.jumpCount = 0; player.onGround = false;
  obstacles = []; coins = []; particles = []; spawnTimer = 0; spawnInterval = 900; distance = 0; score = 0; speed = 3.6; gravity = Math.abs(gravity);
  // pre-spawn
  for(let i=0;i<4;i++) spawnRandomSegment(W() + i*420);
  gameState = 'playing';
}

/* -------------------------
   Save before unload
   ------------------------- */
window.addEventListener('beforeunload', ()=>{ saveState(); });

/* -------------------------
   Final tiny helper: ensure UI shows state
   ------------------------- */
document.getElementById('hudCoins').textContent = state.coins || 0;
document.getElementById('hudBest').textContent = state.best || 0;
document.getElementById('hudScore').textContent = 0;

</script>
</body>
</html>
